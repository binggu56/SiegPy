# -*- coding: utf-8 -*-
"""
Tests for the swpbasisset.py file.
"""

import os
import pytest
import numpy as np
from siegpy import (
    SWPotential,
    SWPContinuum,
    Rectangular,
    Gaussian,
    Eigenstate,
    Potential,
    SWPBasisSet,
)
from siegpy.basisset import BasisSetError, _set_mat_space  # noqa: F401
from siegpy.functions import Function
from siegpy.analyticbasisset import (
    _MLE,  # noqa F401
    _set_mat_space_S,
    _set_mat_space_c,
)
from siegpy.analyticeigenstates import WavenumberError

# Analytical Siegert SWPBasisSet generated by the commands:
# swp = SWPotential(4.442882938158366, 10)
# SWPBasisSet.find_Siegert_states(swp, 200, 3, 1)
filename = "doc/notebooks/siegerts.dat"
siegerts = SWPBasisSet.from_file(filename, nres=5)
bounds = SWPBasisSet.from_file(filename, bounds_only=True)
bnds = siegerts.bounds
abnds = siegerts.antibounds
res = siegerts.resonants
ares = siegerts.antiresonants
cont = siegerts.continuum
pot = siegerts.potential
l = pot.width
xgrid = np.linspace(-l / 2, l / 2, 5)
siegerts_grid = SWPBasisSet.from_file(filename, nres=5, grid=xgrid)

# Analytical continuum SWPBasisSet
k = 1.0
k_2 = 2.0
c_e = SWPContinuum(k, "e", pot, grid=xgrid)
c_o = SWPContinuum(k, "o", pot, grid=xgrid)
c_e_2 = SWPContinuum(k_2, "e", pot, grid=xgrid)
c_o_2 = SWPContinuum(k_2, "o", pot, grid=xgrid)
r = Rectangular.from_center_and_width(0.25, 2.0)
r_even = Rectangular(-1.0, 1.0)
bnds_grid = siegerts_grid.bounds
exact_grid = siegerts_grid.bounds + [c_e, c_o, c_e_2, c_o_2]
kgrid = np.arange(0.1, 5.2, 1.0)
time_grid = [0.0, 1.0]


class TestSWPBasisSet:
    def test_init_raises_ValueError_not_SWPEigenstate(self):
        with pytest.raises(ValueError):
            SWPBasisSet(states=[Eigenstate([-1, 0, 1], [2, 1, 0], 1.0)])

    def test_init_raises_ValueError_different_potentials(self):
        bnd1 = bnds[0]
        bnd2 = bnds[1]
        bnd2._potential = Potential([-1, 0, 1], [2, 1, 0])
        with pytest.raises(ValueError):
            SWPBasisSet(states=[bnd1, bnd2])
        bnd2._potential = bnd1.potential  # reset the correct value

    @pytest.mark.parametrize(
        "state, wavenumber",
        [
            (bnds[0], 0.0 + 4.42578048382546j),
            (abnds[0], 0.0 - 4.402395642496243j),
            (res[0], 2.0632370617399767 - 0.479928756694739j),
            (ares[0], -np.conjugate(res[0].wavenumber)),
        ],
    )
    def test_wavenumbers_from_file(self, state, wavenumber):
        assert np.isclose(state.wavenumber, wavenumber)

    @pytest.mark.parametrize(
        "basis, length",
        [(siegerts, 22), (bnds, 7), (abnds, 5), (res, 5), (ares, 5), (cont, 0)],
    )
    def test_lengths_from_file(self, basis, length):
        assert len(basis) == length

    @pytest.mark.parametrize("basis", [bnds.bounds, siegerts.bounds, bnds_grid])
    def test_from_file_bounds_only(self, basis):
        assert bounds == basis

    def test_from_file_raises_NameError(self):
        with pytest.raises(NameError):
            SWPBasisSet.from_file("fake.dat")

    def test_write_and_from_file(self):
        # Test the writing of a basis set in a temporary file
        tmpfile = "siegpy/tests/tmp.dat"
        exact_grid.write(tmpfile)
        # Test that the temprorary file is removed before being written
        exact_grid.write(tmpfile)
        # Test the reading of the basis set of continuum states
        new_exact = SWPBasisSet.from_file(tmpfile, kmax=1)
        assert new_exact.bounds == exact_grid.bounds
        assert new_exact.continuum.even == SWPBasisSet(states=[c_e])
        assert new_exact.continuum.odd == SWPBasisSet(states=[c_o])
        # Remove the temporary file
        os.remove(tmpfile)

    def test_find_Siegert_states_near_branch_point(self):
        # Test find_Siegert_states when a resonant couple becomes a
        # couple of antibound states by increasing the potential depth:
        # - potential with a resonance couple close to the branch point
        pot1 = SWPotential(3, 4.70)
        s1 = SWPBasisSet.find_Siegert_states(pot1, 5.0, 2.0, 1.0)
        # - potential with anti-bound states close to the branch point
        pot2 = SWPotential(3, 4.71)
        s2 = SWPBasisSet.find_Siegert_states(pot2, 5.0, 2.0, 1.0)
        # Assertions
        assert len(s1.antibounds) == 1
        assert len(s2.antibounds) == 3
        assert len(s1.bounds) == len(s2.bounds)
        assert len(s1.resonants) == len(s2.resonants) + 1
        assert len(s1.antiresonants) == len(s2.antiresonants) + 1

    def test_find_Siegert_states_bounds_only(self):
        p = SWPotential(3, 4.70)
        s = SWPBasisSet.find_Siegert_states(p, 0.0, 0.0, 0.0, bounds_only=True)
        assert s == s.bounds

    @pytest.mark.parametrize(
        "to_evaluate",
        [
            "SWPBasisSet.find_continuum_states(pot, -1, 1)",
            "SWPBasisSet.find_continuum_states(pot, 5, 1, kmin=-1)",
            "SWPBasisSet.find_continuum_states(pot, 5, 0)",
        ],
    )
    def test_find_continuum_states_raises_WavenumberError(self, to_evaluate):
        with pytest.raises(WavenumberError):
            eval(to_evaluate)

    def test_parity(self):
        assert siegerts.parity is None

    @pytest.mark.parametrize("prop", ["grid", "analytic", "potential"])
    def test_get_property_raises_ValueError_empty_basis(self, prop):
        with pytest.raises(ValueError):
            eval("SWPBasisSet().{}".format(prop))

    @pytest.mark.parametrize(
        "grid, other_grid",
        [(None, [-1, 0, 1]), ([-1, 0, 1], None), ([-1, 0, 1], [-2, -1, 0, 1, 2])],
    )
    def test_grid_raises_ValueError_different_grid(self, grid, other_grid):
        bs = SWPBasisSet.from_file(filename, grid=grid)
        bs[1].grid = other_grid
        with pytest.raises(ValueError):
            bs.grid

    @pytest.mark.parametrize("analytic, other_analytic", [(True, False), (False, True)])
    def test_analytic_raises_ValueError_different_grid(self, analytic, other_analytic):
        bs = SWPBasisSet.from_file(filename, analytic=analytic)
        bs[1].analytic = other_analytic
        with pytest.raises(ValueError):
            bs.analytic

    def test_potential_raises_ValueError_different_potential(self):
        bs = SWPBasisSet.from_file(filename)
        bs[1]._potential = Potential([-1, 0, 1], [2, 1, 0])
        with pytest.raises(ValueError):
            bs.potential

    def test_add(self):
        # Test that the add methods sorts the states type by type
        bnd1 = bnds_grid[1]
        abnd1 = abnds[0]
        bs_test = SWPBasisSet(states=[bnd1, abnd1])
        bs_test += bnds_grid[0]
        # We added another bound state of lower energy to a basis set
        # containing a bound state of higher energy and an anti-bound
        # state. The new bound state must be the first state.
        assert bs_test[0] == bnds_grid[0]

    def test_add_raises_TypeError(self):
        # Do not remove the next line!
        siegs = SWPBasisSet.from_file(filename, nres=5)
        with pytest.raises(TypeError):
            siegs += [pot]
        with pytest.raises(TypeError):
            siegs += pot

    def test_wavenumbers(self):
        assert siegerts.wavenumbers == [s.wavenumber for s in siegerts]

    def test_energies(self):
        assert siegerts.energies == [s.energy for s in siegerts]

    def test_scal_prod(self):
        sp_bnds_expected = np.array(
            [
                1.177008 + 0.0j,
                0.300794 + 0.0j,
                0.551730 - 0.0j,
                0.163651 - 0.0j,
                -0.010483 + 0.0j,
                -0.158772 + 0.0j,
                -0.112085 - 0.0j,
            ]
        )
        np.testing.assert_array_almost_equal(bnds_grid.scal_prod(r), sp_bnds_expected)

    def test_MLE_contributions_to_CR(self):
        # Test function with an initial momentum
        test = Gaussian(r.width / 10, r.center, k0=1.0)
        expected = np.array(
            [
                0.133479 - 9.787129e-18j,
                0.013258 - 2.446782e-18j,
                0.094299 + 2.446782e-18j,
                0.038485 + 7.340347e-18j,
                0.045363 + 0.000000e00j,
                0.049518 + 7.340347e-18j,
                0.012407 - 4.587717e-19j,
            ]
        )
        np.testing.assert_array_almost_equal(
            bnds_grid.MLE_contributions_to_CR(test), expected
        )

    def test_MLE_contributions_to_CR_raises_TypeError(self):
        # A TypeError is raised because analytical scalar product is
        # required while the test function cannot allow that.
        r_grid = Rectangular(r.xl, r.xr, grid=[1, 2, 3])
        test = Function(r_grid.grid, r_grid.values)
        with pytest.raises(TypeError):
            siegerts.MLE_contributions_to_CR(test)

    def test_continuum_contributions_to_CR_raises_TypeError(self):
        # A TypeError is raised because analytical scalar product is
        # required while the test function cannot allow that.
        r_grid = Rectangular(r.xl, r.xr, grid=[1, 2, 3])
        test = Function(r_grid.grid, r_grid.values)
        continuum = SWPBasisSet(states=[c_e, c_o, c_e_2, c_o_2])
        with pytest.raises(TypeError):
            continuum.continuum_contributions_to_CR(test)

    def test_cont_contributions_to_CR_raises_BasisSetError_no_cont(self):
        with pytest.raises(BasisSetError):
            siegerts.continuum_contributions_to_CR(r)

    def test_cont_contributions_to_CR_raises_BasisSetError_no_odd_cont(self):
        continuum = SWPBasisSet(states=[c_e, c_o, c_e_2, c_o_2])
        with pytest.raises(BasisSetError):
            print(continuum.even.continuum_contributions_to_CR(r))

    def test_MLE_contributions_to_zero_operator(self):
        # Test function with an initial momentum
        test = Gaussian(r.width / 10, r.center, k0=1.0)
        expected = np.array(
            [
                -2.211391e-18 - 0.03016j,
                -5.711330e-19 - 0.003095j,
                6.058881e-19 - 0.023351j,
                1.999759e-18 - 0.010485j,
                0.000000e00 - 0.014424j,
                3.087505e-18 - 0.020828j,
                -4.396037e-19 - 0.011888j,
            ]
        )
        np.testing.assert_array_almost_equal(
            bnds_grid.MLE_contributions_to_zero_operator(test), expected
        )

    def test_MLE_completeness(self):
        np.testing.assert_almost_equal(
            siegerts.MLE_completeness(r), 0.96540114630986307
        )

    def test_MLE_zero_operator(self):
        np.testing.assert_almost_equal(
            siegerts.MLE_zero_operator(r),
            -8.6736173798840355e-19 - 0.00038860291314806827j,
        )

    def test__MLE_raises_ValueError(self):
        with pytest.raises(ValueError):
            _MLE(siegerts, "toto", r, nres=0)

    def test_exact_completeness(self):
        # the completeness relation and the value at convergence must
        # be almost equal (they should be equal if both results were
        # obtained by the same integration method) TODO?
        CR1 = exact_grid.exact_completeness(r)
        _, CR_c = exact_grid.exact_completeness_convergence(r)
        np.testing.assert_almost_equal(CR1, CR_c[-1])
        # On-the-fly result should give the same result:
        CR2 = siegerts.exact_completeness(r, hk=1, kmax=2)
        assert CR1 == CR2

    @pytest.mark.parametrize(
        "method, expected",
        [
            ("MLE_completeness_convergence", ([0.0], [0.4612232])),
            ("Berggren_completeness_convergence", ([0.0], [2 * 0.4612232])),
            ("MLE_zero_operator_convergence", ([0.0], [0.0 - 0.1098721j])),
        ],
    )
    def test_convergence_methods(self, method, expected):
        np.testing.assert_almost_equal(
            eval("bnds_grid.{}(r, nres=0)".format(method)), expected
        )

    def test_exact_completeness_convergence(self):
        expected = [0.0, 1.0, 2.0], [0.9224464, 0.9237561, 0.9359722]
        expected_even = [0.0, 1.0, 2.0], [0.9335314, 0.934965, 0.9385559]
        # Test the continuum states in the basis mode
        CR_conv = exact_grid.exact_completeness_convergence(r)
        CR_conv_even = exact_grid.exact_completeness_convergence(r_even)
        np.testing.assert_almost_equal(expected, CR_conv)
        np.testing.assert_almost_equal(expected_even, CR_conv_even)
        # Test the on-the-fly definition of continuum states mode
        CR_conv = siegerts.exact_completeness_convergence(r, hk=1, kmax=2)
        CR_conv_even = siegerts.exact_completeness_convergence(r_even, hk=1, kmax=2)
        np.testing.assert_almost_equal(expected, CR_conv)
        np.testing.assert_almost_equal(expected_even, CR_conv_even)

    def test_exact_completeness_convergence_raises_BasisSetError(self):
        # Not enough continuum states in the basis set
        basis = siegerts.bounds + [c_e, c_o]
        with pytest.raises(BasisSetError):
            basis.exact_completeness_convergence(r)

    #    @pytest.mark.parametrize("basis, method",
    #        [(siegerts, "MLE_completeness_convergence"),
    #         (exact_grid, "exact_completeness_convergence")])
    #    def test_completeness_convergence(self, basis, method):
    #        np.testing.assert_almost_equal(basis.completeness_convergence(r),
    #                                       eval("basis.{}(r)".format(method)))

    def test_MLE_strength_function(self):
        # Test that the result is almost equal to its expected value.
        expected = [0.0011176, 0.0097039, 0.0142134, 0.0163033, 0.0167877, 0.016375]
        np.testing.assert_almost_equal(
            bnds_grid.MLE_strength_function(r, kgrid), expected
        )

    @pytest.mark.parametrize(
        "test_func, expected",
        [
            (r, [0.0006824, 0.0060233, 0.0234454, 0.0039414, 0.0004156, 0.0015201]),
            (r_even, [0.001344, 0.0055976, 0.0046848, 0.0069373, 0.0003513, 0.0017803]),
        ],
    )
    def test_exact_strength_function_OTF(self, test_func, expected):
        np.testing.assert_almost_equal(
            bnds_grid.exact_strength_function_OTF(
                test_func, kgrid, hk=10 ** (-2), eta=10 ** (-2)
            ),
            expected,
        )

    @pytest.mark.parametrize(
        "test_func, expected",
        [
            (r, [0.0008341, 0.0008478, 0.0008561, 0.0007844, 0.000595, 0.0003791]),
            (
                r_even,
                [0.0003142, 0.0003172, 0.0003147, 0.0002813, 0.0002097, 0.0001333],
            ),
        ],
    )
    def test_exact_strength_function(self, test_func, expected):
        np.testing.assert_almost_equal(
            exact_grid.exact_strength_function(test_func, kgrid), expected
        )

    def test_exact_propagation(self):
        # Test that the result is almost equal to its expected value.
        np.testing.assert_array_almost_equal(
            exact_grid.exact_propagation(r, time_grid),
            exact_grid.exact_propagation_OTF(r, time_grid, kmax=k_2 + k / 2, hk=k),
        )

    def test_MLE_propagation(self):
        # Test that the result is almost equal to its expected value.
        expected = [
            [
                0.160550 + 0.0j,
                -0.153228 + 0.0j,
                0.994785 + 0.0j,
                0.855366 + 0.0j,
                -0.065969 + 0.0j,
            ],
            [
                4.258355 - 4.229955j,
                -0.658954 + 3.347923j,
                -0.976769 + 0.216613j,
                -0.370865 - 3.831607j,
                -3.690687 + 3.539654j,
            ],
        ]
        np.testing.assert_array_almost_equal(
            expected, siegerts_grid.MLE_propagation(r, time_grid)
        )

    def test_Berggren_propagation(self):
        # Test that the result is almost equal to its expected value.
        expected = [
            [
                0.120956 + 0.056237j,
                -0.182397 - 0.031712j,
                1.005887 + 0.0057j,
                0.886923 - 0.009412j,
                -0.098459 - 0.154117j,
            ],
            [
                0.062060 - 0.063997j,
                -0.228571 - 0.438164j,
                -0.860815 + 0.034619j,
                -0.733676 - 0.356122j,
                -0.077606 - 0.238134j,
            ],
        ]
        np.testing.assert_array_almost_equal(
            siegerts_grid.Berggren_propagation(r, time_grid), expected
        )

    @pytest.mark.parametrize(
        "w, expected_method",
        [
            ({"b": 1, "r": 1}, "Berggren_propagation"),
            (None, "exact_Siegert_propagation"),
        ],
    )
    def test_Siegert_propagation(self, w, expected_method):
        np.testing.assert_array_almost_equal(
            siegerts_grid.Siegert_propagation(r, time_grid, weights=w),
            eval("siegerts_grid.{}(r, time_grid)".format(expected_method)),
        )

    @pytest.mark.parametrize(
        "to_evaluate",
        [
            "bnds_grid.Siegert_propagation(r, time_grid, weights={'e': 1})",
            "siegerts.Siegert_propagation(r, time_grid, weights={'b': 1, 'e': 1})",
        ],
    )
    def test_Siegert_propagation_raises_KeyError(self, to_evaluate):
        with pytest.raises(KeyError):
            eval(to_evaluate)

    def test_exact_Siegert_propagation_return_shape(self):
        # Tests that the function returns a matrix when the basis with
        # an exponential term for time-propagation is empty.
        mat = siegerts_grid.antibounds.exact_Siegert_propagation(r, time_grid)
        assert mat.shape == (len(time_grid), len(xgrid))

    def test_exact_Siegert_propagation_values(self):
        # Test that the result is almost equal to its expected value.
        expected = [
            [
                0.160550 + 0.0j,
                -0.153228 + 0.0j,
                0.994785 + 0.0j,
                0.855366 + 0.0j,
                -0.065969 + 0.0j,
            ],
            [
                0.070821 - 0.072076j,
                -0.224232 - 0.431373j,
                -0.860860 + 0.038198j,
                -0.739404 - 0.356705j,
                -0.086283 - 0.232656j,
            ],
        ]
        np.testing.assert_array_almost_equal(
            siegerts_grid.exact_Siegert_propagation(r, time_grid), expected
        )

    @pytest.mark.parametrize(
        "to_evaluate",
        [
            "SWPBasisSet().exact_Siegert_propagation(r, time_grid)",
            "SWPBasisSet()._propagate(r, time_grid)",
            "_set_mat_space(SWPBasisSet(), r)",
            "_set_mat_space_c(SWPBasisSet(states=[c_e]), r)",
            "_set_mat_space_S(SWPBasisSet(), r, {'b': 1})",
        ],
    )
    def test_propagation_methods_raising_BasisSetError(self, to_evaluate):
        with pytest.raises(BasisSetError):
            eval(to_evaluate)

    def test__propagate(self):
        exact_prop_1 = exact_grid._propagate(r, time_grid, weights={"b": 1})
        exact_prop_2 = exact_grid.exact_propagation(r, time_grid)
        np.testing.assert_array_almost_equal(exact_prop_1, exact_prop_2)

    @pytest.mark.parametrize(
        "to_evaluate", ["siegerts_grid._propagate(r, time_grid)"]  # missing weigths
    )
    def test_propagation_methods_raising_ValueError(self, to_evaluate):
        with pytest.raises(ValueError):
            eval(to_evaluate)

    def test__propagate_raises_BasisSetError(self):
        with pytest.raises(BasisSetError):
            SWPBasisSet(states=[c_e, c_e_2])._propagate(r, time_grid)

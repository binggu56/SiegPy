

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>AnalyticBasisSet &mdash; SiegPy 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="AnalyticEigenstates" href="AnalyticEigenstates.html" />
    <link rel="prev" title="Abstract classes for further analytic cases" href="AbstractClasses.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SiegPy
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api_objects.html">Code Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1DSWPCase.html">1D Square-Well Potential Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="General1DCase.html">General 1D Case</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="AbstractClasses.html">Abstract classes for further analytic cases</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">AnalyticBasisSet</a></li>
<li class="toctree-l3"><a class="reference internal" href="AnalyticEigenstates.html">AnalyticEigenstates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Other.html">The Function class and its children</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SiegPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="api_objects.html">Code Documentation</a> &raquo;</li>
        
          <li><a href="AbstractClasses.html">Abstract classes for further analytic cases</a> &raquo;</li>
        
      <li>AnalyticBasisSet</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/AnalyticBasisSet.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="analyticbasisset">
<h1>AnalyticBasisSet<a class="headerlink" href="#analyticbasisset" title="Permalink to this headline">¶</a></h1>
<p>This abstract base class is meant to implement the main methods available to
all basis set classes that are specific to an analytical case. This ensures
that all analytical cases have the same basic API, while avoiding code
repetition.</p>
<p>As an example, it is used to define the
<a class="reference internal" href="SWPBasisSet.html#siegpy.swpbasisset.SWPBasisSet" title="siegpy.swpbasisset.SWPBasisSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SWPBasisSet</span></code></a> class, which is the specific basis set
class for the analytical 1D Square-Well potential case. You might notice that
only a few methods were implemented there.</p>
<dl class="class">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet">
<em class="property">class </em><code class="descclassname">siegpy.analyticbasisset.</code><code class="descname">AnalyticBasisSet</code><span class="sig-paren">(</span><em>states=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="BasisSet.html#siegpy.basisset.BasisSet" title="siegpy.basisset.BasisSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">siegpy.basisset.BasisSet</span></code></a></p>
<p>This should be the base class for the specific basis set classes
of any analytic cases available in SiegPy.</p>
<p>Its methods allow to compute most the main quantities and forces
the child classes to implement the other ones.</p>
<p>For instance, any relevant Siegert state expansion (such as the
Mittag-Leffler Expansion (MLE), which uses all Siegert states with a
weight 1/2, or the Berggren expansion, which uses only bound and
resonant states with a weight 1) of the quantities of interest (such
as the completeness relation (CR), zero operator, strength function,
strength function and time-propagation must therefore be defined
here, as they should be valid for any analytical case.</p>
<p>On the other hand, all the methods used to define the analytical
eigenstates must be implemented by the child classes.</p>
<p>An AnalyticBasisSet instance is initialized from a list of
<a class="reference internal" href="AnalyticEigenstates.html#siegpy.analyticeigenstates.AnalyticEigenstate" title="siegpy.analyticeigenstates.AnalyticEigenstate"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticEigenstate</span></code></a>
instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>states</strong> (<em>list</em>) – Analytic eigenstates of a Hamiltonian. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, it means
that the BasisSet instance is empty.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If any state comes from a different potential than the
others.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.from_file">
<em class="property">classmethod </em><code class="descname">from_file</code><span class="sig-paren">(</span><em>filename</em>, <em>grid=None</em>, <em>analytic=True</em>, <em>nres=None</em>, <em>kmax=None</em>, <em>bounds_only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a basis set from a binary file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<em>str</em>) – Name of a file containing a basis set.</li>
<li><strong>grid</strong> (<em>numpy array</em><em> or </em><em>list</em><em> or </em><em>set</em>) – Discretization grid of the wavefunctions of the Siegert
states (optional).</li>
<li><strong>analytic</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the scalar products will be computed
analytically.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of resonant couples in the Siegert basis set created
(optional).</li>
<li><strong>kmax</strong> (<em>float</em>) – Value of the maximal continuum wavenumber in the returned
basis set, also containing the bound states, if there were
any in the file (optional).</li>
<li><strong>bounds_only</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the basis set returned contains only bound
states.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The basis set read from the file.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet" title="siegpy.analyticbasisset.AnalyticBasisSet">AnalyticBasisSet</a></p>
</td>
</tr>
</tbody>
</table>
<p>Examples</p>
<p>All the examples given below are given for the SWP analytical
case, but could be easily adapted for any other analytical
cases.</p>
<p>A basis set is read from a file in the following manner:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">SWPBasisSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;doc/notebooks/siegerts.dat&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>It contains a certain number of states, with a given
discretization grid (here, the grid is <code class="docutils literal notranslate"><span class="pre">None</span></code>) and
analyticity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
<span class="go">566</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span><span class="o">.</span><span class="n">grid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">bs</span><span class="o">.</span><span class="n">analytic</span> <span class="o">==</span> <span class="kc">True</span>
</pre></div>
</div>
<p>It is possible to update the grid (and the values of the
eigenstates at the same time) in the 1D SW potential case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span><span class="o">.</span><span class="n">grid</span>
<span class="go">array([-2, -1,  0,  1,  2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="go">[ 0.18053285+0.j  0.51185847+0.j  0.63921710-0.j  0.51185847-0.j</span>
<span class="go">  0.18053285-0.j]</span>
</pre></div>
</div>
<p>The analyticity of the states can also be updated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bs</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">analytic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">bs</span><span class="o">.</span><span class="n">analytic</span> <span class="o">==</span> <span class="kc">False</span>
</pre></div>
</div>
<p>If required, only the bound states are read:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bounds_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
<p>The number of resonant and antiresonant states can also be
chosen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">siegerts</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">siegerts</span><span class="o">.</span><span class="n">antibounds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="o">.</span><span class="n">antibounds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">siegerts</span><span class="o">.</span><span class="n">resonants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">siegerts</span><span class="o">.</span><span class="n">antiresonants</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p>If the basis set contains continuum states, it is also
possible to keep only the states whose wavenumber is
smaller than kmax (in addition to the bound states).</p>
</dd></dl>

<dl class="classmethod">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.find_Siegert_states">
<em class="property">classmethod </em><code class="descname">find_Siegert_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.find_Siegert_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.find_Siegert_states" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an asbtract class method.</p>
</div>
<p>Initialize a basis made of Siegert states found analytically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A basis set made of
<a class="reference internal" href="AnalyticEigenstates.html#siegpy.analyticeigenstates.AnalyticSiegert" title="siegpy.analyticeigenstates.AnalyticSiegert"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticSiegert</span></code></a>
instances.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet" title="siegpy.analyticbasisset.AnalyticBasisSet">AnalyticBasisSet</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.find_continuum_states">
<em class="property">classmethod </em><code class="descname">find_continuum_states</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.find_continuum_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.find_continuum_states" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an asbtract class method.</p>
</div>
<p>Initialize a basis made of continuum states found analytically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A basis set made of
<a class="reference internal" href="AnalyticEigenstates.html#siegpy.analyticeigenstates.AnalyticContinuum" title="siegpy.analyticeigenstates.AnalyticContinuum"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticContinuum</span></code></a>
instances.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet" title="siegpy.analyticbasisset.AnalyticBasisSet">AnalyticBasisSet</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.grid">
<code class="descname">grid</code><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.grid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Value of the discretization grid of all the states in the
basis set.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy array or None</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If at least one state has a different grid than the others
or if the basis set is empty.</td>
</tr>
</tbody>
</table>
<p>Examples</p>
<p>In the following example, the states have no grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">SWPBasisSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s2">&quot;doc/notebooks/siegerts.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also use the
<a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet.grid" title="siegpy.analyticbasisset.AnalyticBasisSet.grid"><code class="xref py py-attr docutils literal notranslate"><span class="pre">grid</span></code></a>
attribute to update the grid (and therefore all the values of
the wavefunctions) of the states in the analytic basis set at
the same time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xgrid</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">xgrid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span>
<span class="go">array([-1,  0,  1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.analytic">
<code class="descname">analytic</code><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.analytic" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Value of the <a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet.analytic" title="siegpy.analyticbasisset.AnalyticBasisSet.analytic"><code class="xref py py-attr docutils literal notranslate"><span class="pre">analytic</span></code></a> attribute of all the states
in the basis set.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If some states have different value for <a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet.analytic" title="siegpy.analyticbasisset.AnalyticBasisSet.analytic"><code class="xref py py-attr docutils literal notranslate"><span class="pre">analytic</span></code></a> or
if the basis set is empty.</td>
</tr>
</tbody>
</table>
<p>Examples</p>
<p>In the following example, all the states require analytic scalar
products:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">SWPBasisSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s2">&quot;doc/notebooks/siegerts.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span><span class="o">.</span><span class="n">analytic</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also use the
<a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet.analytic" title="siegpy.analyticbasisset.AnalyticBasisSet.analytic"><code class="xref py py-attr docutils literal notranslate"><span class="pre">analytic</span></code></a>
attribute to update the values for all the states in the basis
set at the same time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span><span class="o">.</span><span class="n">analytic</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">analytic</span> <span class="o">==</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">siegerts</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.potential">
<code class="descname">potential</code><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.potential" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Potential of all the states in the basis set.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="Potential.html#siegpy.potential.Potential" title="siegpy.potential.Potential">Potential</a></td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If some states come from a different potential or if the
basis set is empty.</td>
</tr>
</tbody>
</table>
<p>Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">SWPBasisSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span> <span class="o">=</span> <span class="n">SWPBasisSet</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s2">&quot;doc/notebooks/siegerts.dat&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">siegerts</span><span class="o">.</span><span class="n">potential</span>
<span class="go">1D Square-Well Potential of width 4.44 and depth 10.00</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.plot_wavefunctions">
<code class="descname">plot_wavefunctions</code><span class="sig-paren">(</span><em>nres=None</em>, <em>xlim=None</em>, <em>ylim=None</em>, <em>title=None</em>, <em>file_save=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.plot_wavefunctions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.plot_wavefunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the bound, resonant and anti-resonant wavefunctions of the
basis set along with the potential. The continuum and anti-bound
states, if any are present in the basis set, are not plotted.</p>
<p>The wavefunctions are translated along the y-axis by their
energy (for bound states) or absolute value of their energy (for
resonant and anti-resonant states).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nres</strong> (<em>int</em>) – Number of resonant and antiresonant wavefunctions to plot.</li>
<li><strong>xlim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the x axis of the plot (optional)</li>
<li><strong>ylim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the y axis of the plot (optional)</li>
<li><strong>title</strong> (<em>str</em>) – Plot title (optional).</li>
<li><strong>file_save</strong> (<em>str</em>) – Filename of the plot to be saved (optional)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If the minimum of the potential cannot be found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.plot_wavenumbers">
<code class="descname">plot_wavenumbers</code><span class="sig-paren">(</span><em>xlim=None</em>, <em>ylim=None</em>, <em>title=None</em>, <em>file_save=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.plot_wavenumbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.plot_wavenumbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the wavenumbers of the Siegert states in the basis set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xlim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the x axis of the plot (optional).</li>
<li><strong>ylim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the y axis of the plot (optional).</li>
<li><strong>title</strong> (<em>str</em>) – Plot title (optional).</li>
<li><strong>file_save</strong> (<em>str</em>) – Filename of the plot to be saved (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.plot_energies">
<code class="descname">plot_energies</code><span class="sig-paren">(</span><em>xlim=None</em>, <em>ylim=None</em>, <em>title=None</em>, <em>file_save=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.plot_energies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.plot_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energies of the Siegert states in the basis set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xlim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the x axis of the plot (optional).</li>
<li><strong>ylim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the y axis of the plot (optional).</li>
<li><strong>title</strong> (<em>str</em>) – Plot title (optional).</li>
<li><strong>file_save</strong> (<em>str</em>) – Filename of the plot to be saved (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_contributions_to_CR">
<code class="descname">MLE_contributions_to_CR</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_contributions_to_CR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_contributions_to_CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the contribution of each state of the basis set to the
completeness relation, according to the Mittag-Leffler
Expansion.</p>
<p>Each element of the array is defined by:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">frac</span><span class="p">{</span> \<span class="n">left</span>\<span class="n">langle</span> <span class="n">test</span> <span class="o">|</span> \<span class="n">varphi_S</span> \<span class="n">right</span><span class="p">)</span>
\<span class="n">left</span><span class="p">(</span> \<span class="n">varphi_S</span> <span class="o">|</span> <span class="n">test</span> \<span class="n">right</span>\<span class="n">rangle</span> <span class="p">}</span>
<span class="p">{</span><span class="mi">2</span> \<span class="n">left</span>\<span class="n">langle</span> <span class="n">test</span> <span class="o">|</span> <span class="n">test</span> \<span class="n">right</span>\<span class="n">rangle</span><span class="p">}</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(\varphi_S\)</span> is a Siegert state of the basis set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Contribution of each state of the basis set to the
completeness relation acording to the Mittag-Leffler
Expansion of the completeness relation.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_contributions_to_zero_operator">
<code class="descname">MLE_contributions_to_zero_operator</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_contributions_to_zero_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_contributions_to_zero_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the contribution of each state of the basis set to the
zero operator, according to the Mittag-Leffler Expansion.</p>
<p>Each element of the returned array is defined by:</p>
<div class="math notranslate nohighlight">
\[\frac{ \left\langle test | \varphi_S \right)
\left( \varphi_S | test \right\rangle }
{2 k_S \left\langle test | test \right\rangle}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_s\)</span> is the wavenumber of the Siegert state
<span class="math notranslate nohighlight">\(\varphi_S\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Contribution of each state of the basis set to the zero
operator acording to the Mittag-Leffler Expansion of the
zero operator.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_completeness">
<code class="descname">MLE_completeness</code><span class="sig-paren">(</span><em>test</em>, <em>nres=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_completeness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the value of the Mittag-Leffler Expansion of the
completeness relation using all Siegert states in the basis set
for a given test function.</p>
<p>Returns the result of the following sum over all Siegert states
<span class="math notranslate nohighlight">\(varphi_S\)</span>:</p>
<div class="math notranslate nohighlight">
\[\sum_S \frac{ \left\langle test | \varphi_S \right)
\left( \varphi_S | test \right\rangle }
{2 \left\langle test | test \right\rangle}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of (anti-)resonant states to use (optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Evaluation of the completeness of the basis set using the
Mittag-Leffler Expansion.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_zero_operator">
<code class="descname">MLE_zero_operator</code><span class="sig-paren">(</span><em>test</em>, <em>nres=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_zero_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_zero_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the value of the Mittag-Leffler Expansion of the zero
operator using all Siegert states in the basis set for a given
test function.</p>
<p>Returns the result of the following sum over all Siegert states:</p>
<div class="math notranslate nohighlight">
\[\sum_S \frac{ \left\langle test | \varphi_S \right)
\left( \varphi_S | test \right\rangle }
{ 2 k_S \left\langle test | test \right\rangle }\]</div>
<p>where <span class="math notranslate nohighlight">\(k_s\)</span> is the wavenumber of the Siegert state
<span class="math notranslate nohighlight">\(\varphi_S\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of (anti-)resonant states to use (optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Evaluation of the zero operator of the basis set using the
Mittag-Leffler Expansion.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_completeness">
<code class="descname">exact_completeness</code><span class="sig-paren">(</span><em>test</em>, <em>hk=None</em>, <em>kmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_completeness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the exact completeness relation using the bound states
of the basis set and the continuum states defined by either
<cite>hk</cite> and <cite>kmax</cite> (respectively the grid-step and
maximum wavenumber of the grid of continuum states) or all the
continuum states in the basis set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>hk</strong> (<em>float</em>) – Grid step for the wavenumbers of the “on-the-fly” continuum
basis sets (optional).</li>
<li><strong>kmax</strong> (<em>float</em>) – Maximal wavenumber of the “on-the-fly” continuum basis set
(optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Value of the exact completeness relation, using bound and
continuum states.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.continuum_contributions_to_CR">
<code class="descname">continuum_contributions_to_CR</code><span class="sig-paren">(</span><em>test</em>, <em>hk=None</em>, <em>kmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.continuum_contributions_to_CR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.continuum_contributions_to_CR" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an asbtract class method.</p>
</div>
<p>Evaluate the continuum contributions to the completeness
relation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>hk</strong> (<em>float</em>) – Grid step for the wavenumbers of the “on-the-fly” continuum
basis sets (optional).</li>
<li><strong>kmax</strong> (<em>float</em>) – Maximal wavenumber of the “on-the-fly” continuum basis set
(optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>numpy array</em> – Contribution of each continuum state of the basis set to the
exact completeness relation.</li>
<li><em>r</em></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_completeness_convergence">
<code class="descname">MLE_completeness_convergence</code><span class="sig-paren">(</span><em>test</em>, <em>nres=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_completeness_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_completeness_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the convergence of the Mittag-Leffler Expansion of the
completeness relation for the basis set, given a test
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of (anti-)resonant states to use (default: use all of
them).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two arrays of the same length. The first one is made of the
absolute value of the resonant wavenumbers, while the second
one is made of the values of the convergence of the MLE of
the completeness relation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple(numpy array, numpy array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.Berggren_completeness_convergence">
<code class="descname">Berggren_completeness_convergence</code><span class="sig-paren">(</span><em>test</em>, <em>nres=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.Berggren_completeness_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.Berggren_completeness_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the convergence of the CR using the Berggren expansion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of resonant states to use (default: use all of them).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two arrays of the same length. The first one is made of the
absolute value of the resonant wavenumbers, while the second
one is made of the values of the convergence of the Berggren
expansion of the completeness relation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple(numpy array, numpy array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_zero_operator_convergence">
<code class="descname">MLE_zero_operator_convergence</code><span class="sig-paren">(</span><em>test</em>, <em>nres=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_zero_operator_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_zero_operator_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the convergence of the Mittag-Leffler Expansion of the
zero operator for the basis set, given a test function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of (anti-)resonant states to use (default: use all of
them).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two arrays of the same length. The first one is made of the
absolute value of the resonant wavenumbers, while the second
one is made of the values of the convergence of the MLE of
the zero operator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple(numpy array, numpy array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_completeness_convergence">
<code class="descname">exact_completeness_convergence</code><span class="sig-paren">(</span><em>test</em>, <em>hk=None</em>, <em>kmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_completeness_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_completeness_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the convergence of the exact completeness relation
(using the continuum and bound states of the basis set) for a
given test function.</p>
<p>A set of continuum states is defined on-the-fly if the values
of both <code class="docutils literal notranslate"><span class="pre">hk</span></code> and <code class="docutils literal notranslate"><span class="pre">kmax</span></code> are not <code class="docutils literal notranslate"><span class="pre">None</span></code> (otherwise,
the continuum states of the basis set, if any, are used).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>hk</strong> (<em>float</em>) – Grid step for the wavenumbers of the “on-the-fly” continuum
basis sets (optional).</li>
<li><strong>kmax</strong> (<em>float</em>) – Maximal wavenumber of the “on-the-fly” continuum basis set
(optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Two arrays of the same length. The first one is made of the
continuum wavenumbers, while the second is made of the
values of the convergence of the exact completeness
relation.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple(numpy array, numpy array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.plot_completeness_convergence">
<code class="descname">plot_completeness_convergence</code><span class="sig-paren">(</span><em>test</em>, <em>hk=None</em>, <em>kmax=None</em>, <em>nres=None</em>, <em>exact=True</em>, <em>MLE=True</em>, <em>title=None</em>, <em>file_save=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.plot_completeness_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.plot_completeness_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the convergence of both the Mittag-Leffler Expansion and
the exact completeness relation for a given test function.</p>
<p>The exact convergence is computed on-the-fly (<em>i.e.</em> without
the need to have continuum states in the basis set):</p>
<ul class="simple">
<li>if <code class="docutils literal notranslate"><span class="pre">hk</span></code> and <code class="docutils literal notranslate"><span class="pre">kmax</span></code> are not <code class="docutils literal notranslate"><span class="pre">None</span></code>,</li>
<li>if <code class="docutils literal notranslate"><span class="pre">exact</span></code> and <code class="docutils literal notranslate"><span class="pre">MLE</span></code> are set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and if
the basis set does not contain enough continuum states to
reach the absolute value of the last resonant wavenumber used
(<code class="docutils literal notranslate"><span class="pre">kmax</span></code> is therefore defined by the wavenumber of the
last resonant state used in the MLE of the CR, and <code class="docutils literal notranslate"><span class="pre">hk</span></code>
is set to a default value)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>hk</strong> (<em>float</em>) – Grid step for the wavenumbers of the “on-the-fly” continuum
basis sets (optional).</li>
<li><strong>kmax</strong> (<em>float</em>) – Maximal wavenumber of the “on-the-fly” continuum basis set
(optional).</li>
<li><strong>nres</strong> (<em>int</em>) – Number of resonant couples contributions to be plotted
(optional).</li>
<li><strong>exact</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the exact strength function.</li>
<li><strong>MLE</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the Mittag-Leffler Expansion
of the strength function.</li>
<li><strong>title</strong> (<em>str</em>) – Plot title (optional).</li>
<li><strong>file_save</strong> (<em>str</em>) – Filename of the plot to be saved (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_strength_function">
<code class="descname">MLE_strength_function</code><span class="sig-paren">(</span><em>test</em>, <em>kgrid</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_strength_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_strength_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the Mittag-Leffler expansion of the strength function
for a given test function. The test function is discretized on
a grid of wavenumbers <code class="docutils literal notranslate"><span class="pre">kgrid</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>kgrid</strong> (<em>numpy array</em>) – Wavenumbers for which the strength function is evaluated.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">MLE of the strength function evaluated over the wavenumber
grid <code class="docutils literal notranslate"><span class="pre">kgrid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_strength_function">
<code class="descname">exact_strength_function</code><span class="sig-paren">(</span><em>test</em>, <em>kgrid</em>, <em>eta=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_strength_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_strength_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the exact strength function over a given wavenumber
grid <code class="docutils literal notranslate"><span class="pre">kgrid</span></code> for a given a test function.</p>
<p><code class="docutils literal notranslate"><span class="pre">eta</span></code> is an infinitesimal used to make the integration over
the continuum states possible (the poles along the real axis
being avoided).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>kgrid</strong> (<em>numpy array</em>) – Wavenumbers for which the strength function is evaluated.</li>
<li><strong>eta</strong> (<em>float</em>) – Infinitesimal for integration (if <code class="docutils literal notranslate"><span class="pre">None</span></code>, default to 10
times the value of the grid-step of the continuum basis
set).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Exact strength function evaluated on the grid of wavenumbers
<code class="docutils literal notranslate"><span class="pre">kgrid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_strength_function_OTF">
<code class="descname">exact_strength_function_OTF</code><span class="sig-paren">(</span><em>test</em>, <em>kgrid</em>, <em>hk=0.0001</em>, <em>eta=None</em>, <em>tol=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_strength_function_OTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_strength_function_OTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the exact strength function “on-the-fly” over a given
wavenumber grid <code class="docutils literal notranslate"><span class="pre">kgrid</span></code> for a given a test function.</p>
<p>It is not necessary to have continuum states in the basis set to
compute the exact strength function, because they can be
computed “on-the-fly” (hence OTF). This even leads to a quicker
evaluation of the strength function because the integral, to be
compute for each point of <code class="docutils literal notranslate"><span class="pre">kgrid</span></code>, actually has an integrand
that peaks around each particular value of <code class="docutils literal notranslate"><span class="pre">kgrid</span></code> and quickly
vanishes around its maximum.</p>
<p>Such a minimal approximated integrand is constructed by using
only the continuum states aroud the point of the <code class="docutils literal notranslate"><span class="pre">kgrid</span></code>
considered, given the tolerance parameter tol.
It allows to reach smaller values of <code class="docutils literal notranslate"><span class="pre">hk</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code>, and
therefore more precise results, in a shorter amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>kgrid</strong> (<em>numpy array</em>) – Wavenumbers for which the strength function is evaluated.</li>
<li><strong>hk</strong> (<em>float</em>) – Grid step for the wavenumbers of the “on-the-fly” continuum
basis sets (optional).</li>
<li><strong>eta</strong> (<em>float</em>) – Infinitesimal for integration (if <code class="docutils literal notranslate"><span class="pre">None</span></code>, default to 10
times the value of the grid-step of the continuum basis
set).</li>
<li><strong>tol</strong> (<em>float</em>) – Tolerance value to truncate the integrand function (ratio of
the value of a possible new point of the integrand to the
maximal value of the integrand).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Approximate exact strength function evaluated on the grid of
wavenumbers <code class="docutils literal notranslate"><span class="pre">kgrid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet._evaluate_integrand">
<em class="property">static </em><code class="descname">_evaluate_integrand</code><span class="sig-paren">(</span><em>q</em>, <em>k</em>, <em>test</em>, <em>eta</em>, <em>potential</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet._evaluate_integrand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet._evaluate_integrand" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an asbtract class method.</p>
</div>
<p>Evaluate the integrand used to compute the strength function
“on-the-fly”. It must be implemented in the child class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>q</strong> (<em>float</em>) – Wavenumber of the continuum state considered.</li>
<li><strong>k</strong> (<em>float</em>) – Wavenumber for which the strength function is evaluated.</li>
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>eta</strong> (<em>float</em>) – Infinitesimal for integration (if <code class="docutils literal notranslate"><span class="pre">None</span></code>, default to 10
times the value of the grid-step of the continuum basis
set).</li>
<li><strong>potential</strong> (<a class="reference internal" href="Potential.html#siegpy.potential.Potential" title="siegpy.potential.Potential"><em>Potential</em></a>) – Potential of the currently studied analytical case.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.plot_strength_function">
<code class="descname">plot_strength_function</code><span class="sig-paren">(</span><em>test</em>, <em>kgrid</em>, <em>nres=None</em>, <em>exact=True</em>, <em>MLE=True</em>, <em>bnds_abnds=False</em>, <em>title=None</em>, <em>file_save=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.plot_strength_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.plot_strength_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the convergence of both the Mittag-Leffler Expansion and
the exact strength function for a given test function.</p>
<p>The exact convergence is computed on-the-fly (without the need
to have continuum states in the BasisSet self).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>kgrid</strong> (<em>numpy array</em>) – Wavenumbers for which the strength function is evaluated.</li>
<li><strong>nres</strong> (<em>int</em>) – Number of resonant couples contributions to be plotted
(default to None, meaning that none are plotted; if
<code class="docutils literal notranslate"><span class="pre">nres=0</span></code>, then only the sum of the bound and anti-bound
states contributions is plotted).</li>
<li><strong>exact</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the exact strength function.</li>
<li><strong>MLE</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the Mittag-Leffler Expansion
of the strength function.</li>
<li><strong>bnds_abnds</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows to plot the individual contributions of
the bound and anti-bound states.</li>
<li><strong>title</strong> (<em>str</em>) – Plot title (optional).</li>
<li><strong>file_save</strong> (<em>str</em>) – Filename of the plot to be saved (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_propagation">
<code class="descname">exact_propagation</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_propagation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the exact time-propagation of a wavepacket <code class="docutils literal notranslate"><span class="pre">test</span></code>
over a given time grid (made of positive numbers only).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Exact propagated wavepacket for the different times of
<code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2D numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_propagation_OTF">
<code class="descname">exact_propagation_OTF</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em>, <em>kmax</em>, <em>hk</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_propagation_OTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_propagation_OTF" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the exact time-propagation of a given test function
for a given time grid after an on-the-fly creation of the
continuum states given the values of <code class="docutils literal notranslate"><span class="pre">kmax</span></code> and <code class="docutils literal notranslate"><span class="pre">hk</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
<li><strong>hk</strong> (<em>float</em>) – Grid step for the wavenumbers of the “on-the-fly” continuum
basis sets (optional).</li>
<li><strong>kmax</strong> (<em>float</em>) – Maximal wavenumber of the “on-the-fly” continuum basis set
(optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>returns: Exact propagated wavepacket for the different times</em> – of <code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</li>
<li><em>rtype: 2D numpy array</em></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.MLE_propagation">
<code class="descname">MLE_propagation</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.MLE_propagation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.MLE_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the Mittag-Leffler Expansion of the time-propagation of
a test wavepacket over a given time grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">MLE of the propagated wavepacket for the different times of
<code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2D numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.Berggren_propagation">
<code class="descname">Berggren_propagation</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.Berggren_propagation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.Berggren_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the Berggren Expansion of the time-propagation of a
test wavepacket over a given time grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Berggren expansion of the propagated wavepacket for the
different times of <code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2D numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.Siegert_propagation">
<code class="descname">Siegert_propagation</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.Siegert_propagation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.Siegert_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a user-defined expansion over the Siegert states of the
time-propagation of a test wavepacket over a given time grid.</p>
<p>The user chooses the weight of each type of Siegert states of
the basis set. If no weights are passed, then exact Siegert
states expansion is performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
<li><strong>weights</strong> (<em>dict</em>) – Dictionary of the weights to use for the time-propagation.
Keys correspond to a type of Siegert states (‘ab’ for
anti-bounds, ‘b’ for bounds, ‘r’ for resonants and ‘ar’ for
anti-resonants) and the corresponding value is the weight to
use for all the states of the given type (optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Siegert states expansion of the propagated wavepacket for
the different times of <code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">2D numpy array</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code> – If an invalid key is found in <code class="docutils literal notranslate"><span class="pre">weights</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.exact_Siegert_propagation">
<code class="descname">exact_Siegert_propagation</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.exact_Siegert_propagation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.exact_Siegert_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the exact Siegert propagation of the initial wavepacket
test for the times of time_grid. In contrast with all other
expansions for the propagation, the time-evolution of the
Siegert states is not only due to an exponential, but also to
state- and time-dependent weights (see eq. 69 of Santra et al.,
PRA 71 (2005)).</p>
<p>There is no need to define any weight, since the correct weight
is known analytically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Exact Siegert expansion of the propagated wavepacket for the
different times of <code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">2D numpy array</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BasisSetError</span></code> – If the basis set contains no Siegert states.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet._propagate">
<code class="descname">_propagate</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet._propagate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet._propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the time-propagation of a test wavepacket as the matrix
product of two matrices: one to account for the time dependance
of the propagation of the wavepacket (mat_time), the other for
its space dependance (mat_space).</p>
<p>The contribution of the continuum states to the time
propagation of the wavepacket requires a numerical integration
that is performed using the composite Simpson’s rule.</p>
<p>The contribution of the Siegert states to the time propagation
of the wavepacket is computed through a discrete sum over all
the Siegert states, with a user-defined weight for each type
of Siegert states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
<li><strong>weights</strong> (<em>dict</em>) – Dictionary of the weights to use for the time-propagation.
Keys correspond to a type of Siegert states (‘ab’ for
anti-bounds, ‘b’ for bounds, ‘r’ for resonants and ‘ar’ for
anti-resonants) and the corresponding value is the weight to
use for all the states of the given type (optional).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Propagated wavepacket for the different times of
<code class="docutils literal notranslate"><span class="pre">time_grid</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">2D numpy array</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BasisSetError</span></code> – If the basis set does not contain Siegert nor continuum
states.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet._add_one_continuum_state">
<code class="descname">_add_one_continuum_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet._add_one_continuum_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet._add_one_continuum_state" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an asbtract class method.</p>
</div>
<p>Add a continuum state to the basis set, depending on the already
existing continuum states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Instance of the child class with one more continuum state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#siegpy.analyticbasisset.AnalyticBasisSet" title="siegpy.analyticbasisset.AnalyticBasisSet">AnalyticBasisSet</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="siegpy.analyticbasisset.AnalyticBasisSet.plot_propagation">
<code class="descname">plot_propagation</code><span class="sig-paren">(</span><em>test</em>, <em>time_grid</em>, <em>exact=True</em>, <em>exact_Siegert=True</em>, <em>MLE=False</em>, <em>Berggren=False</em>, <em>xlim=None</em>, <em>ylim=None</em>, <em>title=None</em>, <em>file_save=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/siegpy/analyticbasisset.html#AnalyticBasisSet.plot_propagation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#siegpy.analyticbasisset.AnalyticBasisSet.plot_propagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the time propagation of a wavepacket using either the exact
expansion (using bound and continuum states), the exact Siegert
states expansion, the Mittag-Leffler Expansion or the Berggren
expansion over a given time grid.</p>
<p>Any of these expansions can be turned on or off by setting the
corresponding optional arguments (<code class="docutils literal notranslate"><span class="pre">exact</span></code>, <code class="docutils literal notranslate"><span class="pre">exact_Siegert</span></code>,
<code class="docutils literal notranslate"><span class="pre">MLE</span></code> and <code class="docutils literal notranslate"><span class="pre">Berggren</span></code> respectively) to <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.
By default, both exact expansions are plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>test</strong> (<a class="reference internal" href="Functions.html#siegpy.functions.Function" title="siegpy.functions.Function"><em>Function</em></a>) – Test function.</li>
<li><strong>time_grid</strong> (<em>numpy array</em><em> or </em><em>list of positive numbers</em>) – Times for which the propagation is evaluated. It must
contain positive numbers only.</li>
<li><strong>exact</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the exact time-propagation
(using bound and continuum states).</li>
<li><strong>exact_Siegert</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the exact time-propagation
(using all Siegert states).</li>
<li><strong>MLE</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the Mittag-Leffler Expansion
of the time-propagation.</li>
<li><strong>Berggren</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, allows the plot of the Berggren expansion of
the time-propagation.</li>
<li><strong>xlim</strong> (<em>tuple</em><em>(</em><em>float</em><em> or </em><em>int</em><em>, </em><em>float</em><em> or </em><em>int</em><em>)</em>) – Range of the x axis of the plot (optional).</li>
<li><strong>xlim</strong> – Range of the y axis of the plot (optional).</li>
<li><strong>title</strong> (<em>str</em>) – Plot title (optional).</li>
<li><strong>file_save</strong> (<em>str</em>) – Base name of the files where the plots are to be saved
(optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="AnalyticEigenstates.html" class="btn btn-neutral float-right" title="AnalyticEigenstates" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="AbstractClasses.html" class="btn btn-neutral" title="Abstract classes for further analytic cases" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Maxime Morinière.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>siegpy.functions &mdash; SiegPy 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> SiegPy
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_objects.html">Code Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SiegPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>siegpy.functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for siegpy.functions</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The class :class:`Function` is the base class for various other</span>
<span class="sd">classes of interest, which are:</span>

<span class="sd">* the :class:`~siegpy.functions.AnalyticFunction` class, to represent</span>
<span class="sd">  analytic functions,</span>
<span class="sd">* the :class:`~siegpy.functions.potential.Potential` class, to</span>
<span class="sd">  represent a potential.</span>
<span class="sd">* the :class:`~siegpy.functions.eigenstate.Eigenstate` class, to</span>
<span class="sd">  represent eigenstates of a potential.</span>

<span class="sd">Two classes used to represent two particular types of analytic</span>
<span class="sd">functions are also defined here:</span>

<span class="sd">1. :class:`~siegpy.functions.Gaussian`, to represent a Gaussian</span>
<span class="sd">   function,</span>
<span class="sd">2. :class:`~siegpy.functions.Rectangular`, to represent a rectangular</span>
<span class="sd">   function.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">siegpy.utils</span> <span class="k">import</span> <span class="n">init_plot</span><span class="p">,</span> <span class="n">finalize_plot</span>


<div class="viewcode-block" id="Function"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function">[docs]</a><span class="k">class</span> <span class="nc">Function</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class defining a 1-dimendional (1D) function from its grid and</span>
<span class="sd">    the corresponding values.</span>

<span class="sd">    A function can be plotted, and different types of operations can</span>
<span class="sd">    be performed (*e.g.*, scalar product with another function,</span>
<span class="sd">    addition of another function). It is also possible to compute its</span>
<span class="sd">    norm, and return its conjugate and its absolute value as another</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: list or set or numpy array</span>
<span class="sd">            Discretization grid.</span>
<span class="sd">        values: list or set or numpy array</span>
<span class="sd">            Values of the function evaluated on the grid points.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the grid is not made of reals or if the ``grid`` and</span>
<span class="sd">            ``values`` arrays have incoherent lengths.</span>

<span class="sd">        Example</span>

<span class="sd">        Note that both ``grid`` and ``values`` are converted to numpy</span>
<span class="sd">        arrays:</span>

<span class="sd">        &gt;&gt;&gt; f = Function([-1, 0, 1], [1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; f.grid</span>
<span class="sd">        array([-1,  0,  1])</span>
<span class="sd">        &gt;&gt;&gt; f.values</span>
<span class="sd">        array([1, 2, 3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the grid and values have consistent lengths</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Both grid and values must have the same length (</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">)&quot;</span>\
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Check that the grid is not made of complex numbers</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The grid has to be made of reals.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Grid of a Function instance.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The grid of a Function instance cannot be modified:</span>

<span class="sd">            &gt;&gt;&gt; f = Function([-1, 0, 1], [1, 2, 3])</span>
<span class="sd">            &gt;&gt;&gt; f.grid = [-1, 1]</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            AttributeError: can&#39;t set attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Values of a Function instance.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The values of a Function instance cannot be modified:</span>

<span class="sd">            &gt;&gt;&gt; f = Function([-1, 0, 1], [1, 2, 3])</span>
<span class="sd">            &gt;&gt;&gt; f.values = [3, 0, 1]</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            AttributeError: can&#39;t set attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

<div class="viewcode-block" id="Function.__eq__"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Two functions are equal if they have the same grid and values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: object</span>
<span class="sd">            Another object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if ``other`` is a Function instance with the same</span>
<span class="sd">            :attr:`grid` and :attr:`values`.</span>

<span class="sd">        Examples</span>

<span class="sd">        &gt;&gt;&gt; f = Function([1, 2, 3], [1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; Function([1, 2, 3], [1, 1, 1]) == f</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Function([1, 2, 3], [-1, 0, 1]) == f</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Function([-1, 0, 1], [1, 1, 1]) == f</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; f == 1</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">))</span></div>

<div class="viewcode-block" id="Function.__add__"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two functions, if both grids are the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Function</span>
<span class="sd">            Another function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Function</span>
<span class="sd">            Sum of both functions.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If both the :attr:`grid` of both functions differ.</span>

<span class="sd">        Examples</span>

<span class="sd">        Two functions can be added:</span>

<span class="sd">        &gt;&gt;&gt; f1 = Function([1, 2, 3], [1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; f2 = Function([1, 2, 3], [0, -1, 0])</span>
<span class="sd">        &gt;&gt;&gt; f = f1 + f2</span>

<span class="sd">        The grid of the new function is the same, and its values are</span>
<span class="sd">        the sum of both values:</span>

<span class="sd">        &gt;&gt;&gt; f.grid</span>
<span class="sd">        array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; f.values</span>
<span class="sd">        array([1, 0, 1])</span>

<span class="sd">        It leaves the other functions unchanged:</span>

<span class="sd">        &gt;&gt;&gt; f1.values</span>
<span class="sd">        array([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; f2.values</span>
<span class="sd">        array([ 0, -1,  0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Both Functions must be discretized on the same grid.&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the function is even, ``False`` if not.</span>

<span class="sd">        Examples</span>

<span class="sd">        &gt;&gt;&gt; Function([1, 2, 3], [1j, 1j, 1j]).is_even</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Function([-1, 0, 1], [1j, 1j, 1j]).is_even</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="n">half</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">npts</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">npts</span><span class="o">-</span><span class="n">half</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">npts</span><span class="o">-</span><span class="n">half</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the function is odd, ``False`` if not.</span>

<span class="sd">        Examples</span>

<span class="sd">        &gt;&gt;&gt; Function([-1, 0, 1], [-1j, 0j, 1j]).is_odd</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Function([1, 2, 3], [-1j, 0j, 1j]).is_odd</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="n">half</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">npts</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">npts</span><span class="o">-</span><span class="n">half</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span>
                                   <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">npts</span><span class="o">-</span><span class="n">half</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="Function.plot"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover  # noqa</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the real and imaginary parts of the function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the x axis of the plot (optional).</span>
<span class="sd">        ylim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the y axis of the plot (optional).</span>
<span class="sd">        title: str</span>
<span class="sd">            Title for the plot.</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Filename of the plot to be saved (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Object-oriented plots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">init_plot</span><span class="p">()</span>
        <span class="c1"># Define the plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im&#39;</span><span class="p">)</span>
        <span class="c1"># Finalize the plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">finalize_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                      <span class="n">file_save</span><span class="o">=</span><span class="n">file_save</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;$x$&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function.abs"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.abs">[docs]</a>    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Function</span>
<span class="sd">            Absolute value of the function.</span>

<span class="sd">        Example</span>

<span class="sd">        Applying the :meth:`abs` method to a :class:`Function` instance</span>
<span class="sd">        returns a new :class:`Function` instance (*i.e.*, the initial</span>
<span class="sd">        one is unchanged):</span>

<span class="sd">        &gt;&gt;&gt; f = Function([1, 2, 3], [1j, 1j, 1j])</span>
<span class="sd">        &gt;&gt;&gt; f.abs().values</span>
<span class="sd">        array([ 1.,  1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; f.values</span>
<span class="sd">        array([ 0.+1.j,  0.+1.j,  0.+1.j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span></div>

<div class="viewcode-block" id="Function.conjugate"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.conjugate">[docs]</a>    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Function</span>
<span class="sd">            Conjugate of the function.</span>

<span class="sd">        Example</span>

<span class="sd">        Applying the :meth:`conjugate` method to a :class:`Function`</span>
<span class="sd">        instance returns a new :class:`Function` instance (*i.e.* the</span>
<span class="sd">        initial one is unchanged):</span>

<span class="sd">        &gt;&gt;&gt; f = Function([1, 2, 3], [1j, 1j, 1j])</span>
<span class="sd">        &gt;&gt;&gt; f.conjugate().values</span>
<span class="sd">        array([ 0.-1.j,  0.-1.j,  0.-1.j])</span>
<span class="sd">        &gt;&gt;&gt; f.values</span>
<span class="sd">        array([ 0.+1.j,  0.+1.j,  0.+1.j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span></div>

<div class="viewcode-block" id="Function.scal_prod"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.scal_prod">[docs]</a>    <span class="k">def</span> <span class="nf">scal_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the usual scalar product of two functions f and g:</span>

<span class="sd">        :math:`\langle f | g \rangle = \int f^*(x)  g(x) \text{d}x`</span>

<span class="sd">        where `*` represents the conjugation.</span>

<span class="sd">        .. note::</span>

<span class="sd">            * The trapezoidal integration rule is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Function</span>
<span class="sd">            Another function.</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the x-axis for the integration (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Value of the scalar product</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the grid of both functions are different or if the</span>
<span class="sd">            interval given by ``xlim`` is not inside the one defined by</span>
<span class="sd">            the discretization grid.</span>

<span class="sd">        Example</span>

<span class="sd">        &gt;&gt;&gt; grid = [-1, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; f = Function(grid, [1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = Function(grid, np.ones_like(grid))</span>
<span class="sd">        &gt;&gt;&gt; f.scal_prod(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that both have the same grid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both grids are different.&quot;</span><span class="p">)</span>
        <span class="c1"># Reduce the interval where the scalar product is computed,</span>
        <span class="c1"># if desired</span>
        <span class="k">if</span> <span class="n">xlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check the limits are well-defined</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">xlim</span>
            <span class="k">if</span> <span class="n">xl</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="ow">or</span> <span class="n">xr</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The interval defined by xlim must be inside the grid.&quot;</span><span class="p">)</span>
            <span class="c1"># Define the contracted grid and functions</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">xl</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">xr</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">where</span><span class="p">]</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">where</span><span class="p">]</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">where</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Use the trapezoidal integration rule for the integration.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="o">*</span><span class="n">f2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function.norm"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.Function.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Norm of the function.</span>

<span class="sd">        Example</span>

<span class="sd">        &gt;&gt;&gt; Function([-1, 0, 1], [2j, 0, 2j]).norm()</span>
<span class="sd">        (4+0j)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is nothing but the scalar product of the function with</span>
        <span class="c1"># itself.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AnalyticFunction"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.AnalyticFunction">[docs]</a><span class="k">class</span> <span class="nc">AnalyticFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note::</span>

<span class="sd">        **This is an abstract class.** A child class must implement the</span>
<span class="sd">        :class:`~siegpy.functions.AnalyticFunction._compute_values`</span>
<span class="sd">        class. Examples of such child classes are:</span>

<span class="sd">        * the :class:`~siegpy.functions.Rectangular` class,</span>
<span class="sd">        * the :class:`~siegpy.functions.Gaussian` class.</span>

<span class="sd">    The main change with respect to the</span>
<span class="sd">    :class:`siegpy.functions.Function` class is that the grid is an</span>
<span class="sd">    optional parameter, so that, if it is modified, then the values of</span>
<span class="sd">    the function are updated accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: list or set or numpy array</span>
<span class="sd">            Discretization grid (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="AnalyticFunction.evaluate"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.AnalyticFunction.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for the</span>
<span class="sd">        :func:`~siegpy.functions.AnalyticFunction._compute_values` to</span>
<span class="sd">        evaluate the analytic function either for a grid of points or a</span>
<span class="sd">        single point in the 1-dimensional space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: int or float or numpy array</span>
<span class="sd">            Discretization grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or complex or numpy array</span>
<span class="sd">            Values of the function for all the grid points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Convert the grid to a numpy array before computing the values</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_values</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># The grid is made of one element: return a single element</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grid</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_values</span><span class="p">(</span><span class="n">grid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnalyticFunction._compute_values"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.AnalyticFunction._compute_values">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_compute_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an abstract method.</span>

<span class="sd">        Compute the values of the function given a discretization grid</span>
<span class="sd">        that has been converted to a numpy array by the</span>
<span class="sd">        :meth:`~siegpy.functions.AnalyticFunction.evaluate` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: numpy array</span>
<span class="sd">            Discretization grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Values of the analytic function over the provided ``grid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :attr:`grid` still is an attribute, but it is more powerful than</span>
<span class="sd">        for a :class:`~siegpy.functions.Function` instance: when the</span>
<span class="sd">        grid of an :class:`AnalyticFunction` instance is updated, so are</span>
<span class="sd">        its values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">grid</span>

    <span class="nd">@grid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter of the :attr:`grid` attribute, updating the values of</span>
<span class="sd">        the function at the same time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_grid: list or set or numpy array</span>
<span class="sd">            New discretization grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span>
            <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">,</span> <span class="n">new_values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">AnalyticFunction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="AnalyticFunction.__add__"><a class="viewcode-back" href="../../Functions.html#siegpy.functions.AnalyticFunction.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Function, or any class inheriting from it</span>
<span class="sd">            Another Function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Function</span>
<span class="sd">            Sum of an :class:`AnalyticFunction` instance with</span>
<span class="sd">            another function. It requires that at least one of both</span>
<span class="sd">            functions has a grid that is not ``None``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If both functions have grids set to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Two analytic functions not discretized cannot be added.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Perform the addition by adding a grid to a copy of</span>
                <span class="c1"># self (in order not to modify it).</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
                <span class="k">return</span> <span class="n">new</span> <span class="o">+</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Perform the addition by adding a grid to a copy of other</span>
            <span class="c1"># (in order not to modify it).</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Both functions have a discretization grid: perform the</span>
            <span class="c1"># usual addition of two functions</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">Gaussian</span><span class="p">(</span><span class="n">AnalyticFunction</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Gaussian function is characterized by:</span>

<span class="sd">    * a width ``sigma``</span>
<span class="sd">    * a center ``xc``</span>
<span class="sd">    * an initial momentum ``k0``</span>
<span class="sd">    * an amplitude ``h``</span>

<span class="sd">    In addition to the behaviour of an analytic function:</span>

<span class="sd">    * the norm is computed analytically,</span>
<span class="sd">    * the attribute :attr:`~siegpy.functions.Gaussian.is_even` returns</span>
<span class="sd">      ``True`` if the Gaussian function is centered, even if the</span>
<span class="sd">      discretization grid is not centered,</span>
<span class="sd">    * the equality and addition of two Gaussian functions are also</span>
<span class="sd">      defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma: strictly positive float</span>
<span class="sd">            Width of the Gaussian function.</span>
<span class="sd">        xc: float</span>
<span class="sd">            Center of the Gaussian function.</span>
<span class="sd">        k0: float</span>
<span class="sd">            Initial momentum of the Gaussian function (default to 0).</span>
<span class="sd">        h: float</span>
<span class="sd">            Maximal amplitude of the Gaussian function (default to 1).</span>
<span class="sd">        grid: list or set or numpy array</span>
<span class="sd">            Discretization grid (optional).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``sigma`` is negative.</span>

<span class="sd">        Examples</span>

<span class="sd">        A Gaussian function is characterized by various attributes:</span>

<span class="sd">        &gt;&gt;&gt; g = Gaussian(4, 2, k0=5)</span>
<span class="sd">        &gt;&gt;&gt; g.sigma</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; g.center</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; g.momentum</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; g.amplitude</span>
<span class="sd">        1.0</span>

<span class="sd">        If no discretization grid is passed, then the atrributes</span>
<span class="sd">        :attr:`~siegpy.functions.AnalyticFunction.grid` and</span>
<span class="sd">        :attr:`~siegpy.functions.AnalyticFunction.values` are set to</span>
<span class="sd">        ``None``:</span>

<span class="sd">        &gt;&gt;&gt; g.grid is None and g.values is None</span>
<span class="sd">        True</span>

<span class="sd">        If a grid is given, the Gaussian is discretized:</span>

<span class="sd">        &gt;&gt;&gt; g1 = Gaussian(4, 2, k0=5, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; g2 = Gaussian(4, 2, k0=5, h=2, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; np.array_equal(g2.values, 2*g1.values)</span>
<span class="sd">        True</span>

<span class="sd">        .. note::</span>

<span class="sd">            The only way to modify the values of a Gaussian is by</span>
<span class="sd">            setting its grid:</span>

<span class="sd">            &gt;&gt;&gt; g.grid = [-1, 0, 1]</span>
<span class="sd">            &gt;&gt;&gt; assert np.array_equal(g.grid, g1.grid)</span>
<span class="sd">            &gt;&gt;&gt; assert np.array_equal(g.values, g1.values)</span>
<span class="sd">            &gt;&gt;&gt; g.values = [2, 1, 2]</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            AttributeError: can&#39;t set attribute</span>

<span class="sd">        .. warning::</span>

<span class="sd">            Finally, a Gaussian function must have a strictly positive</span>
<span class="sd">            sigma:</span>

<span class="sd">            &gt;&gt;&gt; Gaussian(-1, 1)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ValueError: The Gaussian must have a strictly positive sigma.</span>
<span class="sd">            &gt;&gt;&gt; Gaussian(0, 1)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ValueError: The Gaussian must have a strictly positive sigma.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the initial values</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The Gaussian must have a strictly positive sigma.&quot;</span><span class="p">)</span>
        <span class="c1"># Set the attirbutes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">xc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_momentum</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_amplitude</span> <span class="o">=</span> <span class="n">h</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Width of the Gaussian function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Center of the Gaussian function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">momentum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Momentum of the Gaussian function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_momentum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Amplitude of the Gaussian function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amplitude</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shortcut to get the main parameters of a Gaussian function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            sigma, center and amplitude of the Gaussian function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: object</span>
<span class="sd">            Another object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if both Gaussian functions have the same sigma,</span>
<span class="sd">            center, momentum and amplitude.</span>

<span class="sd">        Examples</span>

<span class="sd">        Two Gaussian functions with different amplitudes are different:</span>

<span class="sd">        &gt;&gt;&gt; g1 = Gaussian(4, 2, k0=5, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; g2 = Gaussian(4, 2, k0=5, h=2, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; g1 == g2</span>
<span class="sd">        False</span>

<span class="sd">        If only the grid differs, then the two Gaussian functions are</span>
<span class="sd">        the same:</span>

<span class="sd">        &gt;&gt;&gt; g3 = Gaussian(4, 2, k0=5, grid=[-1, -0.5, 0, 0.5, 1])</span>
<span class="sd">        &gt;&gt;&gt; g1 == g3</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">momentum</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">amplitude</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># as it is definietly not a Gaussian</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add another function to a Gaussian function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Function</span>
<span class="sd">            Another function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gaussian or Function.</span>
<span class="sd">            Sum of a Gaussian function with another function.</span>

<span class="sd">        Example</span>

<span class="sd">        Two Gaussian functions differing only by the amplitude can be</span>
<span class="sd">        added to give another Gaussian function:</span>

<span class="sd">        &gt;&gt;&gt; g1 = Gaussian(1, 0)</span>
<span class="sd">        &gt;&gt;&gt; g2 = Gaussian(1, 0, h=3)</span>
<span class="sd">        &gt;&gt;&gt; g = g1 + g2</span>
<span class="sd">        &gt;&gt;&gt; assert g.amplitude == 4</span>
<span class="sd">        &gt;&gt;&gt; assert g.center == g1.center</span>
<span class="sd">        &gt;&gt;&gt; assert g.sigma == g1.sigma</span>
<span class="sd">        &gt;&gt;&gt; assert g.momentum == g1.momentum</span>

<span class="sd">        Two different Gaussian functions that were not discretized</span>
<span class="sd">        cannot be added:</span>

<span class="sd">        &gt;&gt;&gt; g1 + Gaussian(1, 1)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ValueError: Two analytic functions not discretized cannot be added.</span>

<span class="sd">        Finally, if the Gaussian function is not discretized over a</span>
<span class="sd">        grid, but the other function is, then the addition can be</span>
<span class="sd">        performed:</span>

<span class="sd">        &gt;&gt;&gt; g = g1 + Function([-1, 0, 1], [1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; g.grid</span>
<span class="sd">        array([-1,  0,  1])</span>
<span class="sd">        &gt;&gt;&gt; g.values</span>
<span class="sd">        array([ 1.60653066+0.j,  3.00000000+0.j,  3.60653066+0.j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the other function is the same Gaussian function,</span>
        <span class="c1"># except for the amplitude, then return a Gaussian instance</span>
        <span class="c1"># with the correct amplitude</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">center</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sigma</span> \
                    <span class="ow">and</span> <span class="n">k0</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">momentum</span><span class="p">:</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">amplitude</span>
                <span class="k">return</span> <span class="n">Gaussian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h1</span><span class="o">+</span><span class="n">h2</span><span class="p">,</span>
                                <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="c1"># Otherwise, proceed as expected from an AnalyticFunction</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Representation of a Gaussian instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Gaussian function of width </span><span class="si">{:.2f}</span><span class="s2"> and centered in </span><span class="si">{:.2f}</span><span class="s2">&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Gaussian function is even.</span>

<span class="sd">        Examples</span>

<span class="sd">        A centered Gaussian with no initial momentum is even, even if</span>
<span class="sd">        its grid is not centered:</span>

<span class="sd">        &gt;&gt;&gt; Gaussian(2, 0, grid=[-2, -1, 0]).is_even</span>
<span class="sd">        True</span>

<span class="sd">        A non-centered Gaussian is not even:</span>

<span class="sd">        &gt;&gt;&gt; Gaussian(2, 2).is_even</span>
<span class="sd">        False</span>

<span class="sd">        A centered Gaussian with a non-zero initial momentum is</span>
<span class="sd">        not even:</span>

<span class="sd">        &gt;&gt;&gt; Gaussian(2, 0, k0=1).is_even</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="mf">0.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``False``, as a Gaussian function can&#39;t be odd.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw_pot</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the Gaussian function can be considered as inside the</span>
<span class="sd">        1D Square-Well potential, given a tolerance value that must be</span>
<span class="sd">        larger than the values of the Gaussian function at the border of</span>
<span class="sd">        the potential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sw_pot: SWPotential</span>
<span class="sd">            1D potential.</span>
<span class="sd">        tol: float</span>
<span class="sd">            Tolerance value (default to :math:`10^{-5}`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the Gaussian function is inside the 1D SWP.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``sw_pot`` is not a</span>
<span class="sd">            :class:`~siegpy.swpotential.SWPotential` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">SWPotential</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sw_pot</span><span class="p">,</span> <span class="n">SWPotential</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;potential is not a SWPotential instance&quot;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">sw_pot</span><span class="o">.</span><span class="n">width</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="o">+</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gaussian</span>
<span class="sd">            Absolute value of the Gaussian function.</span>

<span class="sd">        Example</span>

<span class="sd">        The absolute value of a Gaussian function is nothing but</span>
<span class="sd">        the same Gaussian function without initial momentum:</span>

<span class="sd">        &gt;&gt;&gt; g = Gaussian(5, -1, h=4, k0=-6)</span>
<span class="sd">        &gt;&gt;&gt; assert g.abs() == Gaussian(5, -1, h=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="k">return</span> <span class="n">Gaussian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gaussian</span>
<span class="sd">            Conjugate of the Gaussian function.</span>

<span class="sd">        Example</span>

<span class="sd">        The conjugate of a Gaussian is the same Gaussian function</span>
<span class="sd">        with a negative momentum:</span>

<span class="sd">        &gt;&gt;&gt; g = Gaussian(5, -1, h=4, k0=-6)</span>
<span class="sd">        &gt;&gt;&gt; assert g.conjugate() == Gaussian(5, -1, h=4, k0=6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="n">k_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span>
        <span class="k">return</span> <span class="n">Gaussian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">k0</span><span class="o">=-</span><span class="n">k_0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Analytic norm of the Gaussian function.</span>

<span class="sd">        Example</span>

<span class="sd">        The norm of a Gaussian function does not depend on the</span>
<span class="sd">        discretization grid:</span>

<span class="sd">        &gt;&gt;&gt; g1 = Gaussian(2, 0)</span>
<span class="sd">        &gt;&gt;&gt; g2 = Gaussian(2, 0, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; assert g1.norm() == g2.norm()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_compute_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the Gaussian for each grid point :math:`x_0`:</span>
<span class="sd">        :math:`a e^{-\frac{(x_0-xc)^2}{2 sigma^2}} * e^{i k_0 x}`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: numpy array</span>
<span class="sd">            Discretization grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or complex</span>
<span class="sd">            Value of the Gaussian function over the grid.</span>

<span class="sd">        Example</span>

<span class="sd">        &gt;&gt;&gt; g = Gaussian(5, -1, h=-3.5)</span>
<span class="sd">        &gt;&gt;&gt; g.evaluate(-1) == -3.5</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="p">(</span><span class="n">grid</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                       <span class="o">+</span> <span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Rectangular</span><span class="p">(</span><span class="n">AnalyticFunction</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rectangular function is characterized by:</span>

<span class="sd">    * a left and right border ``xl`` and ``xr`` (or, alternatively, by</span>
<span class="sd">      a width :math:`a = xr - xl` and a center ``xc``; see</span>
<span class="sd">      :meth:`~siegpy.functions.Rectangular.from_center_and_width` or</span>
<span class="sd">      :meth:`~siegpy.functions.Rectangular.from_width_and_center`),</span>
<span class="sd">    * an initial momentum ``k0``,</span>
<span class="sd">    * an amplitude ``h``.</span>

<span class="sd">    In addition to the behaviour of an analytic function:</span>

<span class="sd">    * the norm is computed analytically,</span>
<span class="sd">    * the attribute :attr:`~siegpy.functions.Rectangular.is_even`</span>
<span class="sd">      returns ``True`` if the rectangular function is centered, even if</span>
<span class="sd">      the discretization grid is not centered,</span>
<span class="sd">    * the equality and addition of two rectangular functions are also</span>
<span class="sd">      defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xl: float</span>
<span class="sd">            Left border of the rectangular function.</span>
<span class="sd">        xr: float</span>
<span class="sd">            Right border of the rectangular function.</span>
<span class="sd">        k0: float</span>
<span class="sd">            Initial momentum of the rectangular function (default to 0).</span>
<span class="sd">        h: float</span>
<span class="sd">            Maximal amplitude of the rectangular function (default to</span>
<span class="sd">            1).</span>
<span class="sd">        grid: list or set or numpy array</span>
<span class="sd">            Discretization grid (optional).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the amplitude ``h`` is zero or if the width is negative.</span>

<span class="sd">        Examples</span>

<span class="sd">        A rectangular function has several attributes:</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular(-4, 2, k0=5)</span>
<span class="sd">        &gt;&gt;&gt; r.xl</span>
<span class="sd">        -4</span>
<span class="sd">        &gt;&gt;&gt; r.xr</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; r.width</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; r.center</span>
<span class="sd">        -1.0</span>
<span class="sd">        &gt;&gt;&gt; r.momentum</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; r.amplitude</span>
<span class="sd">        1.0</span>

<span class="sd">        If no discretization grid is passed, then the atrributes</span>
<span class="sd">        :attr:`~siegpy.functions.AnalyticFunction.grid` and</span>
<span class="sd">        :attr:`~siegpy.functions.AnalyticFunction.values` are set to</span>
<span class="sd">        ``None``:</span>

<span class="sd">        &gt;&gt;&gt; r.grid is None and r.values is None</span>
<span class="sd">        True</span>

<span class="sd">        If a grid is passed, then the rectangular function is</span>
<span class="sd">        discretized (meaning its attribute</span>
<span class="sd">        :attr:`~siegpy.functions.AnalyticFunction.values` is not</span>
<span class="sd">        ``None``):</span>

<span class="sd">        &gt;&gt;&gt; r1 = Rectangular(-4, 2, k0=5, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; r2 = Rectangular(-4, 2, k0=5, h=2, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; np.array_equal(r2.values, 2*r1.values)</span>
<span class="sd">        True</span>

<span class="sd">        .. note::</span>
<span class="sd">            The only way of modifying the values of a Rectangular instance</span>
<span class="sd">            is by setting a new grid:</span>

<span class="sd">            &gt;&gt;&gt; r.grid = [-1, 0, 1]</span>
<span class="sd">            &gt;&gt;&gt; assert np.array_equal(r.grid, r1.grid)</span>
<span class="sd">            &gt;&gt;&gt; assert np.array_equal(r.values, r1.values)</span>
<span class="sd">            &gt;&gt;&gt; r.values = [2, 1, 2]</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            AttributeError: can&#39;t set attribute</span>

<span class="sd">        .. warning::</span>

<span class="sd">            A rectangular function must have a strictly positive width:</span>

<span class="sd">            &gt;&gt;&gt; Rectangular(1, -1)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ValueError: The width must be strictly positive.</span>
<span class="sd">            &gt;&gt;&gt; Rectangular(1, 1)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ValueError: The width must be strictly positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the width and amplitude</span>
        <span class="k">if</span> <span class="n">xl</span> <span class="o">&gt;=</span> <span class="n">xr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The width must be strictly positive.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The amplitude of the rectangular function must not be 0&quot;</span><span class="p">)</span>
        <span class="c1"># Initialize the attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xl</span> <span class="o">=</span> <span class="n">xl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xr</span> <span class="o">=</span> <span class="n">xr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_amplitude</span> <span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">=</span> <span class="n">xr</span> <span class="o">-</span> <span class="n">xl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">xl</span> <span class="o">+</span> <span class="n">xr</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_momentum</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_center_and_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of a rectangular function centered in ``xc``, of</span>
<span class="sd">        width ``a``, with an amplitude ``h`` and with an initial</span>
<span class="sd">        momentum ``k0``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xc: float</span>
<span class="sd">            Center of the rectangular function.</span>
<span class="sd">        width: float</span>
<span class="sd">            Width of the rectangular function.</span>
<span class="sd">        k0: float</span>
<span class="sd">            Initial momentum of the rectangular function (default to 0).</span>
<span class="sd">        h: float</span>
<span class="sd">            Maximal amplitude of the rectangular function (default</span>
<span class="sd">            to 1.).</span>
<span class="sd">        grid: list or set or numpy array</span>
<span class="sd">            Discretization grid (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rectangular</span>
<span class="sd">            An initialized rectangular function.</span>

<span class="sd">        Example</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular.from_center_and_width(4, 2)</span>
<span class="sd">        &gt;&gt;&gt; r.xl</span>
<span class="sd">        3.0</span>
<span class="sd">        &gt;&gt;&gt; r.xr</span>
<span class="sd">        5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xc</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">xc</span><span class="o">+</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_width_and_center</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to the class method</span>
<span class="sd">        :meth:`~siegpy.functions.Rectangular.from_center_and_width`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rectangular</span>
<span class="sd">            An initialized rectangular function.</span>

<span class="sd">        Example</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular.from_width_and_center(4, 2)</span>
<span class="sd">        &gt;&gt;&gt; r.xl</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; r.xr</span>
<span class="sd">        4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_center_and_width</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Left border of the rectangular function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xl</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Right border of the rectangular function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Amplitude of the rectangular function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amplitude</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Width of the rectangular function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Center of the rectangular function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">momentum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Momentum of the rectangular function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_momentum</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            Another object</span>
<span class="sd">        other: object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if both objects are Rectangular functions with the</span>
<span class="sd">            same amplitude, width, center and momentum.</span>

<span class="sd">        Examples</span>

<span class="sd">        Two rectangular functions with different amplitudes are</span>
<span class="sd">        different:</span>

<span class="sd">        &gt;&gt;&gt; r1 = Rectangular(-4, 2, k0=5, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; r2 = Rectangular(-4, 2, k0=5, h=2, grid=[-1, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; r1 == r2</span>
<span class="sd">        False</span>

<span class="sd">        Two rectangular functions that are identical, except for the</span>
<span class="sd">        grid, are considered to be the same:</span>

<span class="sd">        &gt;&gt;&gt; r3 = Rectangular(-4, 2, k0=5, grid=[-1, -0.5, 0, 0.5, 1])</span>
<span class="sd">        &gt;&gt;&gt; r1 == r3</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Rectangular</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">momentum</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">amplitude</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add another function to a rectangular function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other: Function</span>
<span class="sd">            Another function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rectangular or Function.</span>
<span class="sd">            Sum of a rectangular function with another function.</span>

<span class="sd">        Example</span>

<span class="sd">        Two rectangular functions differing only by the amplitude can</span>
<span class="sd">        be added to give another rectangular function:</span>

<span class="sd">        &gt;&gt;&gt; r1 = Rectangular(-1, 1)</span>
<span class="sd">        &gt;&gt;&gt; r2 = Rectangular(-1, 1, h=3)</span>
<span class="sd">        &gt;&gt;&gt; r = r1 + r2</span>
<span class="sd">        &gt;&gt;&gt; assert r.amplitude == 4</span>
<span class="sd">        &gt;&gt;&gt; assert r.center == r1.center</span>
<span class="sd">        &gt;&gt;&gt; assert r.width == r1.width</span>
<span class="sd">        &gt;&gt;&gt; assert r.momentum == r1.momentum</span>

<span class="sd">        Two different rectangular functions that were not discretized</span>
<span class="sd">        cannot be added:</span>

<span class="sd">        &gt;&gt;&gt; r1 + Rectangular(-2, 2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ValueError: Two analytic functions not discretized cannot be added.</span>

<span class="sd">        Finally, if the rectangular function is not discretized over a</span>
<span class="sd">        grid, but the other function is, then the addition can be</span>
<span class="sd">        performed:</span>

<span class="sd">        &gt;&gt;&gt; r = r1 + Function([-1, 0, 1], [1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; r.grid</span>
<span class="sd">        array([-1,  0,  1])</span>
<span class="sd">        &gt;&gt;&gt; r.values</span>
<span class="sd">        array([ 2.+0.j,  3.+0.j,  4.+0.j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the other function is the same rectangular function,</span>
        <span class="c1"># except for the amplitude, then return a Rectangular instance</span>
        <span class="c1"># with the correct amplitude</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Rectangular</span><span class="p">):</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">center</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">width</span> \
               <span class="ow">and</span> <span class="n">k0</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">momentum</span><span class="p">:</span>
                <span class="n">h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
                <span class="n">h2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">amplitude</span>
                <span class="k">return</span> <span class="n">Rectangular</span><span class="o">.</span><span class="n">from_width_and_center</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h1</span><span class="o">+</span><span class="n">h2</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="c1"># Otherwise, proceed as expected from an AnalyticFunction</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Representation of a Rectangular instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Rectangular function of width </span><span class="si">{s.width:.2f}</span><span class="s2"> and centered &quot;</span>
                <span class="s2">&quot;in </span><span class="si">{s.center:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the rectangular function is even.</span>

<span class="sd">        Examples</span>

<span class="sd">        A centered rectangular function is even, even if t grid is</span>
<span class="sd">        not centered:</span>

<span class="sd">        &gt;&gt;&gt; Rectangular(-2, 2, grid=[-2, -1, 0]).is_even</span>
<span class="sd">        True</span>

<span class="sd">        A non-centered rectangular function cannot be even:</span>

<span class="sd">        &gt;&gt;&gt; Rectangular(-2, 0).is_even</span>
<span class="sd">        False</span>

<span class="sd">        A centered rectangular function with an initial momentum</span>
<span class="sd">        cannot be even:</span>

<span class="sd">        &gt;&gt;&gt; Rectangular(-2, 2, k0=1).is_even</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">==</span> <span class="mf">0.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``False``, as a rectangular function can&#39;t be odd.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_compute_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluation of the Rectangular function for each grid point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: numpy array</span>
<span class="sd">            Discretization grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Value of the Rectangular function over the grid.</span>

<span class="sd">        Examples</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular(-5, 1, h=-3.5)</span>
<span class="sd">        &gt;&gt;&gt; r.evaluate(-1) == -3.5</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; r.evaluate(-10) == 0</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use the numpy vectorization to divide the grid in three</span>
        <span class="n">where_1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">grid</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">)</span>
        <span class="n">where_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">grid</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="n">grid</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr</span><span class="p">)</span>
        <span class="n">where_3</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">grid</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr</span><span class="p">)</span>
        <span class="n">grid_1</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">where_1</span><span class="p">]</span>
        <span class="n">grid_2</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">where_2</span><span class="p">]</span>
        <span class="n">grid_3</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">where_3</span><span class="p">]</span>
        <span class="c1"># Evaluate the recytangular function and return it</span>
        <span class="n">values_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">grid_1</span><span class="p">)</span>
        <span class="n">values_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span> <span class="o">*</span> <span class="n">grid_2</span><span class="p">)</span>
        <span class="n">values_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">grid_3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">values_1</span><span class="p">,</span> <span class="n">values_2</span><span class="p">,</span> <span class="n">values_3</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rectangular</span>
<span class="sd">            Absolute value of the Rectangular function.</span>

<span class="sd">        Example</span>

<span class="sd">        The absolute value of a Rectangular function is nothing but</span>
<span class="sd">        the same Rectangular function without initial momentum:</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular(-5, 1, h=4, k0=-6)</span>
<span class="sd">        &gt;&gt;&gt; assert r.abs() == Rectangular(-5, 1, h=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Rectangular</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Rectangular</span>
<span class="sd">            Conjugate of the Rectangular function.</span>

<span class="sd">        Example</span>

<span class="sd">        The conjugate of a Rectangular is the same Rectangular</span>
<span class="sd">        function with a negative momentum:</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular(-5, 1, h=4, k0=-6)</span>
<span class="sd">        &gt;&gt;&gt; assert r.conjugate() == Rectangular(-5, 1, h=4, k0=6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="n">k_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span>
        <span class="k">return</span> <span class="n">Rectangular</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">k0</span><span class="o">=-</span><span class="n">k_0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Analytic norm of a rectangular function, that is equal to</span>
<span class="sd">            its width times its amplitude squared.</span>

<span class="sd">        Examples</span>

<span class="sd">        &gt;&gt;&gt; r = Rectangular(-1, 1, h=3)</span>
<span class="sd">        &gt;&gt;&gt; r.norm()</span>
<span class="sd">        18</span>

<span class="sd">        The norm does not depend on the discretization grid:</span>

<span class="sd">        &gt;&gt;&gt; r.norm() == Rectangular(-1, 1, h=3, grid=[-1, 0, 1]).norm()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw_pot</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split the rectangular function into three other rectangular</span>
<span class="sd">        functions, each one spreading over only one of the three regions</span>
<span class="sd">        defined by a 1D Square-Well potential SWP. If the original</span>
<span class="sd">        rectangular function does not spread over one particular region,</span>
<span class="sd">        the returned value for this region is ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sw_pot: SWPotential</span>
<span class="sd">            1D Square-Well Potential</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of length 3</span>
<span class="sd">            Three rectangular functions.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``sw_pot`` is not a</span>
<span class="sd">            :class:`~siegpy.swpotential.SWPotential` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the argument sw_pot is a SWPotential instance</span>
        <span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">SWPotential</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sw_pot</span><span class="p">,</span> <span class="n">SWPotential</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The argument must be a SWPotential.&quot;</span><span class="p">)</span>
        <span class="c1"># Initial parameters of the rectangular function</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">sw_pot</span><span class="o">.</span><span class="n">width</span>
        <span class="n">xl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xl</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xr</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">momentum</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="c1"># Rectangular function in region I</span>
        <span class="k">if</span> <span class="n">xl</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">r_1</span> <span class="o">=</span> <span class="n">Rectangular</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">xr</span><span class="p">,</span> <span class="o">-</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Rectangular function in region III</span>
        <span class="k">if</span> <span class="n">xr</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">r_3</span> <span class="o">=</span> <span class="n">Rectangular</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">xr</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_3</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Rectangular function in region II</span>
        <span class="k">if</span> <span class="n">xl</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">xr</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">r_2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xl</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">xl_2</span> <span class="o">=</span> <span class="o">-</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xl_2</span> <span class="o">=</span> <span class="n">xl</span>
            <span class="k">if</span> <span class="n">xr</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">xr_2</span> <span class="o">=</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xr_2</span> <span class="o">=</span> <span class="n">xr</span>
            <span class="n">r_2</span> <span class="o">=</span> <span class="n">Rectangular</span><span class="p">(</span><span class="n">xl_2</span><span class="p">,</span> <span class="n">xr_2</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="n">k0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r_1</span><span class="p">,</span> <span class="n">r_2</span><span class="p">,</span> <span class="n">r_3</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Maxime Morinière.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
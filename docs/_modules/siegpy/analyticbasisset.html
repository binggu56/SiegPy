

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>siegpy.analyticbasisset &mdash; SiegPy 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> SiegPy
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_objects.html">Code Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SiegPy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>siegpy.analyticbasisset</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for siegpy.analyticbasisset</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The :class:`AnalyticBasisSet` class and its methods are defined hereafter.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># TODO: Add a create_exact_basis_set method (for AnalyticBasisSet)?</span>


<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">wofz</span>
<span class="kn">from</span> <span class="nn">siegpy</span> <span class="k">import</span> <span class="n">BasisSet</span><span class="p">,</span> <span class="n">BasisSetError</span>
<span class="kn">from</span> <span class="nn">siegpy.utils</span> <span class="k">import</span> <span class="n">init_plot</span><span class="p">,</span> <span class="n">finalize_plot</span>
<span class="kn">from</span> <span class="nn">siegpy.basisset</span> <span class="k">import</span> <span class="n">_set_mat_time</span><span class="p">,</span> <span class="n">_set_mat_space</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AnalyticBasisSet&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="AnalyticBasisSet"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet">[docs]</a><span class="k">class</span> <span class="nc">AnalyticBasisSet</span><span class="p">(</span><span class="n">BasisSet</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This should be the base class for the specific basis set classes</span>
<span class="sd">    of any analytic cases available in SiegPy.</span>

<span class="sd">    Its methods allow to compute most the main quantities and forces</span>
<span class="sd">    the child classes to implement the other ones.</span>

<span class="sd">    For instance, any relevant Siegert state expansion (such as the</span>
<span class="sd">    Mittag-Leffler Expansion (MLE), which uses all Siegert states with a</span>
<span class="sd">    weight 1/2, or the Berggren expansion, which uses only bound and</span>
<span class="sd">    resonant states with a weight 1) of the quantities of interest (such</span>
<span class="sd">    as the completeness relation (CR), zero operator, strength function,</span>
<span class="sd">    strength function and time-propagation must therefore be defined</span>
<span class="sd">    here, as they should be valid for any analytical case.</span>

<span class="sd">    On the other hand, all the methods used to define the analytical</span>
<span class="sd">    eigenstates must be implemented by the child classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An AnalyticBasisSet instance is initialized from a list of</span>
<span class="sd">        :class:`~siegpy.analyticeigenstates.AnalyticEigenstate`</span>
<span class="sd">        instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        states: list</span>
<span class="sd">            Analytic eigenstates of a Hamiltonian. If ``None``, it means</span>
<span class="sd">            that the BasisSet instance is empty.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any state comes from a different potential than the</span>
<span class="sd">            others.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort the list of states</span>
        <span class="n">new_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">states</span><span class="p">:</span>
            <span class="c1"># Check that all states come from the same potential</span>
            <span class="n">pot</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">potential</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">potential</span> <span class="o">!=</span> <span class="n">pot</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;All the eigenstates must come from the same potential&quot;</span><span class="p">)</span>
            <span class="c1"># Loop over each type of states</span>
            <span class="k">for</span> <span class="n">S_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STATES_TYPES</span><span class="p">:</span>
                <span class="c1"># Sort each type of state by increasing real energy</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">Siegert_type</span> <span class="o">==</span> <span class="n">S_type</span><span class="p">]</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
                <span class="c1"># Update the list of states</span>
                <span class="n">new_states</span> <span class="o">+=</span> <span class="n">tmp</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">states</span><span class="o">=</span><span class="n">new_states</span><span class="p">)</span>

<div class="viewcode-block" id="AnalyticBasisSet.from_file"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analytic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a basis set from a binary file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename: str</span>
<span class="sd">            Name of a file containing a basis set.</span>
<span class="sd">        grid: numpy array or list or set</span>
<span class="sd">            Discretization grid of the wavefunctions of the Siegert</span>
<span class="sd">            states (optional).</span>
<span class="sd">        analytic: bool</span>
<span class="sd">            If ``True``, the scalar products will be computed</span>
<span class="sd">            analytically.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of resonant couples in the Siegert basis set created</span>
<span class="sd">            (optional).</span>
<span class="sd">        kmax: float</span>
<span class="sd">            Value of the maximal continuum wavenumber in the returned</span>
<span class="sd">            basis set, also containing the bound states, if there were</span>
<span class="sd">            any in the file (optional).</span>
<span class="sd">        bounds_only: bool</span>
<span class="sd">            If ``True``, the basis set returned contains only bound</span>
<span class="sd">            states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AnalyticBasisSet</span>
<span class="sd">            The basis set read from the file.</span>

<span class="sd">        Examples</span>

<span class="sd">        All the examples given below are given for the SWP analytical</span>
<span class="sd">        case, but could be easily adapted for any other analytical</span>
<span class="sd">        cases.</span>

<span class="sd">        A basis set is read from a file in the following manner:</span>

<span class="sd">        &gt;&gt;&gt; from siegpy import SWPBasisSet</span>
<span class="sd">        &gt;&gt;&gt; filename = &quot;doc/notebooks/siegerts.dat&quot;</span>
<span class="sd">        &gt;&gt;&gt; bs = SWPBasisSet.from_file(filename)</span>

<span class="sd">        It contains a certain number of states, with a given</span>
<span class="sd">        discretization grid (here, the grid is ``None``) and</span>
<span class="sd">        analyticity:</span>

<span class="sd">        &gt;&gt;&gt; len(bs)</span>
<span class="sd">        566</span>
<span class="sd">        &gt;&gt;&gt; bs.grid</span>
<span class="sd">        &gt;&gt;&gt; assert bs.analytic == True</span>

<span class="sd">        It is possible to update the grid (and the values of the</span>
<span class="sd">        eigenstates at the same time) in the 1D SW potential case:</span>

<span class="sd">        &gt;&gt;&gt; bs = SWPBasisSet.from_file(filename, grid=[-2, -1, 0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; bs.grid</span>
<span class="sd">        array([-2, -1,  0,  1,  2])</span>
<span class="sd">        &gt;&gt;&gt; print(bs[0].values)</span>
<span class="sd">        [ 0.18053285+0.j  0.51185847+0.j  0.63921710-0.j  0.51185847-0.j</span>
<span class="sd">          0.18053285-0.j]</span>

<span class="sd">        The analyticity of the states can also be updated:</span>

<span class="sd">        &gt;&gt;&gt; bs = SWPBasisSet.from_file(filename, analytic=False)</span>
<span class="sd">        &gt;&gt;&gt; assert bs.analytic == False</span>

<span class="sd">        If required, only the bound states are read:</span>

<span class="sd">        &gt;&gt;&gt; bounds = SWPBasisSet.from_file(filename, bounds_only=True)</span>
<span class="sd">        &gt;&gt;&gt; assert len(bounds) == len(bs.bounds)</span>

<span class="sd">        The number of resonant and antiresonant states can also be</span>
<span class="sd">        chosen:</span>

<span class="sd">        &gt;&gt;&gt; siegerts = SWPBasisSet.from_file(filename, nres=5)</span>
<span class="sd">        &gt;&gt;&gt; assert len(siegerts.bounds) == len(bs.bounds)</span>
<span class="sd">        &gt;&gt;&gt; assert len(siegerts.antibounds) == len(bs.antibounds)</span>
<span class="sd">        &gt;&gt;&gt; assert len(siegerts.resonants) == 5</span>
<span class="sd">        &gt;&gt;&gt; assert len(siegerts.antiresonants) == 5</span>

<span class="sd">        If the basis set contains continuum states, it is also</span>
<span class="sd">        possible to keep only the states whose wavenumber is</span>
<span class="sd">        smaller than kmax (in addition to the bound states).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read the basis set from the file</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c1"># Keep only the required states</span>
        <span class="k">if</span> <span class="n">bounds_only</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">elif</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="n">basis</span><span class="o">.</span><span class="n">antibounds</span> <span class="o">+</span>
                     <span class="n">basis</span><span class="o">.</span><span class="n">resonants</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span> <span class="o">+</span> <span class="n">basis</span><span class="o">.</span><span class="n">antiresonants</span><span class="p">[:</span><span class="n">nres</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">kmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cont</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">basis</span><span class="o">.</span><span class="n">continuum</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">wavenumber</span> <span class="o">&lt;=</span> <span class="n">kmax</span><span class="p">]</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="n">cont</span>
        <span class="c1"># Update the analyticity and the grid of each state in the</span>
        <span class="c1"># basis set before returning it</span>
        <span class="n">basis</span><span class="o">.</span><span class="n">analytic</span> <span class="o">=</span> <span class="n">analytic</span>
        <span class="n">basis</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">return</span> <span class="n">basis</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.find_Siegert_states"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.find_Siegert_states">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">find_Siegert_states</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an asbtract class method.</span>

<span class="sd">        Initialize a basis made of Siegert states found analytically.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AnalyticBasisSet</span>
<span class="sd">            A basis set made of</span>
<span class="sd">            :class:`~siegpy.analyticeigenstates.AnalyticSiegert`</span>
<span class="sd">            instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.find_continuum_states"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.find_continuum_states">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">find_continuum_states</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an asbtract class method.</span>

<span class="sd">        Initialize a basis made of continuum states found analytically.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AnalyticBasisSet</span>
<span class="sd">            A basis set made of</span>
<span class="sd">            :class:`~siegpy.analyticeigenstates.AnalyticContinuum`</span>
<span class="sd">            instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array or None</span>
<span class="sd">            Value of the discretization grid of all the states in the</span>
<span class="sd">            basis set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If at least one state has a different grid than the others</span>
<span class="sd">            or if the basis set is empty.</span>

<span class="sd">        Examples</span>

<span class="sd">        In the following example, the states have no grid:</span>

<span class="sd">        &gt;&gt;&gt; from siegpy import SWPBasisSet</span>
<span class="sd">        &gt;&gt;&gt; siegerts = SWPBasisSet.from_file(&quot;doc/notebooks/siegerts.dat&quot;)</span>
<span class="sd">        &gt;&gt;&gt; siegerts.grid is None</span>
<span class="sd">        True</span>

<span class="sd">        You can also use the</span>
<span class="sd">        :attr:`~siegpy.analyticbasisset.AnalyticBasisSet.grid`</span>
<span class="sd">        attribute to update the grid (and therefore all the values of</span>
<span class="sd">        the wavefunctions) of the states in the analytic basis set at</span>
<span class="sd">        the same time:</span>

<span class="sd">        &gt;&gt;&gt; xgrid = [-1, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; siegerts.grid = xgrid</span>
<span class="sd">        &gt;&gt;&gt; siegerts[-1].grid</span>
<span class="sd">        array([-1,  0,  1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
            <span class="n">xgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">if</span> <span class="n">xgrid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Some states have a different value for &#39;grid&#39;&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span> <span class="ow">or</span> \
                        <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">xgrid</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Some states have a different value for &#39;grid&#39;&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">xgrid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empy basis set, it has no &#39;grid&#39; attribute&quot;</span><span class="p">)</span>

    <span class="nd">@grid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the :attr:`grid` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_grid: list or numpy array</span>
<span class="sd">            New grid to apply to all the states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Value of the :attr:`analytic` attribute of all the states</span>
<span class="sd">            in the basis set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If some states have different value for :attr:`analytic` or</span>
<span class="sd">            if the basis set is empty.</span>

<span class="sd">        Examples</span>

<span class="sd">        In the following example, all the states require analytic scalar</span>
<span class="sd">        products:</span>

<span class="sd">        &gt;&gt;&gt; from siegpy import SWPBasisSet</span>
<span class="sd">        &gt;&gt;&gt; siegerts = SWPBasisSet.from_file(&quot;doc/notebooks/siegerts.dat&quot;)</span>
<span class="sd">        &gt;&gt;&gt; siegerts.analytic</span>
<span class="sd">        True</span>

<span class="sd">        You can also use the</span>
<span class="sd">        :attr:`~siegpy.analyticbasisset.AnalyticBasisSet.analytic`</span>
<span class="sd">        attribute to update the values for all the states in the basis</span>
<span class="sd">        set at the same time:</span>

<span class="sd">        &gt;&gt;&gt; siegerts.analytic = False</span>
<span class="sd">        &gt;&gt;&gt; all([state.analytic == False for state in siegerts])</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
            <span class="n">analytic</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">analytic</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">analytic</span> <span class="o">==</span> <span class="n">analytic</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">analytic</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Some states have a different value for &#39;analytic&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empy basis set, it has no &#39;analytic&#39; attribute&quot;</span><span class="p">)</span>

    <span class="nd">@analytic</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the :attr:`analytic` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value: bool</span>
<span class="sd">            New value to apply to all the states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">analytic</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">potential</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Potential</span>
<span class="sd">            Potential of all the states in the basis set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If some states come from a different potential or if the</span>
<span class="sd">            basis set is empty.</span>

<span class="sd">        Example</span>

<span class="sd">        &gt;&gt;&gt; from siegpy import SWPBasisSet</span>
<span class="sd">        &gt;&gt;&gt; siegerts = SWPBasisSet.from_file(&quot;doc/notebooks/siegerts.dat&quot;)</span>
<span class="sd">        &gt;&gt;&gt; siegerts.potential</span>
<span class="sd">        1D Square-Well Potential of width 4.44 and depth 10.00</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
            <span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">potential</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">potential</span> <span class="o">==</span> <span class="n">pot</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">pot</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Some states come from a different potential&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empy basis set, it has no &#39;potential&#39; attribute&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AnalyticBasisSet.plot_wavefunctions"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.plot_wavefunctions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_wavefunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the bound, resonant and anti-resonant wavefunctions of the</span>
<span class="sd">        basis set along with the potential. The continuum and anti-bound</span>
<span class="sd">        states, if any are present in the basis set, are not plotted.</span>

<span class="sd">        The wavefunctions are translated along the y-axis by their</span>
<span class="sd">        energy (for bound states) or absolute value of their energy (for</span>
<span class="sd">        resonant and anti-resonant states).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of resonant and antiresonant wavefunctions to plot.</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the x axis of the plot (optional)</span>
<span class="sd">        ylim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the y axis of the plot (optional)</span>
<span class="sd">        title: str</span>
<span class="sd">            Plot title (optional).</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Filename of the plot to be saved (optional)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the minimum of the potential cannot be found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Object-oriented plots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">init_plot</span><span class="p">()</span>
        <span class="c1"># Set useful variables</span>
        <span class="n">potential</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonants</span>
        <span class="n">ares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiresonants</span>
        <span class="c1"># Plot only part of the resonances, if asked by the user</span>
        <span class="k">if</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
            <span class="n">ares</span> <span class="o">=</span> <span class="n">ares</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
        <span class="n">siegerts_to_plot</span> <span class="o">=</span> <span class="n">bnds</span> <span class="o">+</span> <span class="n">res</span> <span class="o">+</span> <span class="n">ares</span>  <span class="c1"># List of Siegert states</span>
        <span class="c1"># Loop over the Siegert states</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">siegerts_to_plot</span><span class="p">):</span>
            <span class="c1"># Define the value of its energy given its type</span>
            <span class="k">if</span> <span class="n">wf</span><span class="o">.</span><span class="n">Siegert_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span><span class="p">):</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">wf</span><span class="o">.</span><span class="n">Siegert_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">):</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
            <span class="c1"># Define the labels</span>
            <span class="n">label_re</span><span class="p">,</span> <span class="n">label_im</span><span class="p">,</span> <span class="n">label_en</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">label_re</span><span class="p">,</span> <span class="n">label_im</span><span class="p">,</span> <span class="n">label_en</span> <span class="o">=</span> <span class="s1">&#39;Re[WF]&#39;</span><span class="p">,</span> <span class="s1">&#39;Im[WF]&#39;</span><span class="p">,</span> <span class="s1">&#39;Energy&#39;</span>
            <span class="c1"># Add the wf (real and imaginary parts) in the plot</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">+</span><span class="n">energy</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label_re</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">+</span><span class="n">energy</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label_im</span><span class="p">)</span>
            <span class="c1"># Also plot the value of its (&quot;translation&quot;) energy.</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">energy</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">wf</span><span class="o">.</span><span class="n">grid</span><span class="p">)),</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">label_en</span><span class="p">)</span>
        <span class="c1"># Plot the potential as well</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">potential</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">potential</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re[Potential]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">potential</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">potential</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">,</span>
                <span class="n">ms</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im[Potential]&#39;</span><span class="p">)</span>
        <span class="c1"># Finalize the plot</span>
        <span class="c1"># Set the range of the plot on the y-axis (ylim)</span>
        <span class="k">if</span> <span class="n">ylim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Define the minimum of the y-axis:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">potential</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">):</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">potential</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find the minimum of the potential&quot;</span><span class="p">)</span>
            <span class="c1"># Define the maximum of the y-axis</span>
            <span class="k">if</span> <span class="n">nres</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
            <span class="n">ylim</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="n">finalize_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                      <span class="n">file_save</span><span class="o">=</span><span class="n">file_save</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;$x$&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Energy&quot;</span><span class="p">,</span>
                      <span class="n">leg_loc</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">leg_bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.plot_wavenumbers"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.plot_wavenumbers">[docs]</a>    <span class="k">def</span> <span class="nf">plot_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the wavenumbers of the Siegert states in the basis set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the x axis of the plot (optional).</span>
<span class="sd">        ylim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the y axis of the plot (optional).</span>
<span class="sd">        title: str</span>
<span class="sd">            Plot title (optional).</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Filename of the plot to be saved (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_complex_plane_plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="s1">&#39;wavenumber&#39;</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.plot_energies"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.plot_energies">[docs]</a>    <span class="k">def</span> <span class="nf">plot_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the energies of the Siegert states in the basis set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the x axis of the plot (optional).</span>
<span class="sd">        ylim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the y axis of the plot (optional).</span>
<span class="sd">        title: str</span>
<span class="sd">            Plot title (optional).</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Filename of the plot to be saved (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_complex_plane_plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_contributions_to_CR"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_contributions_to_CR">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_contributions_to_CR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the contribution of each state of the basis set to the</span>
<span class="sd">        completeness relation, according to the Mittag-Leffler</span>
<span class="sd">        Expansion.</span>

<span class="sd">        Each element of the array is defined by:</span>
<span class="sd">        .. math::</span>

<span class="sd">            \frac{ \left\langle test | \varphi_S \right)</span>
<span class="sd">            \left( \varphi_S | test \right\rangle }</span>
<span class="sd">            {2 \left\langle test | test \right\rangle}</span>

<span class="sd">        where :math:`\varphi_S` is a Siegert state of the basis set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Contribution of each state of the basis set to the</span>
<span class="sd">            completeness relation acording to the Mittag-Leffler</span>
<span class="sd">            Expansion of the completeness relation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the test function needs to be explicitely</span>
        <span class="c1"># conjugated:</span>
        <span class="c1"># TODO: add the case of a complex test function if not analytic</span>
        <span class="c1">#       scalar products</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conjugate_test</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">momentum</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">conjugate_test</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Contribution of each Siegert state to the MLE of the CR</span>
        <span class="n">siegerts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span>
        <span class="n">scal_prods</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conjugate_test</span><span class="p">:</span>
            <span class="n">scal_prods_l</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
            <span class="n">MLE_contribs</span> <span class="o">=</span> <span class="n">scal_prods</span> <span class="o">*</span> <span class="n">scal_prods_l</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MLE_contribs</span> <span class="o">=</span> <span class="n">scal_prods</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">MLE_contribs</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">test</span><span class="o">.</span><span class="n">norm</span><span class="p">()))</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_contributions_to_zero_operator"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_contributions_to_zero_operator">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_contributions_to_zero_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the contribution of each state of the basis set to the</span>
<span class="sd">        zero operator, according to the Mittag-Leffler Expansion.</span>

<span class="sd">        Each element of the returned array is defined by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{ \left\langle test | \varphi_S \right)</span>
<span class="sd">            \left( \varphi_S | test \right\rangle }</span>
<span class="sd">            {2 k_S \left\langle test | test \right\rangle}</span>

<span class="sd">        where :math:`k_s` is the wavenumber of the Siegert state</span>
<span class="sd">        :math:`\varphi_S`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Contribution of each state of the basis set to the zero</span>
<span class="sd">            operator acording to the Mittag-Leffler Expansion of the</span>
<span class="sd">            zero operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># One just needs to compute the contributions of each state to</span>
        <span class="c1"># the MLE of the CR and then divide each contribution by the</span>
        <span class="c1"># wavenumber of the corresponding state.</span>
        <span class="c1"># Thanks to numpy, this can be done in one line.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">MLE_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_completeness"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_completeness">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_completeness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the value of the Mittag-Leffler Expansion of the</span>
<span class="sd">        completeness relation using all Siegert states in the basis set</span>
<span class="sd">        for a given test function.</span>

<span class="sd">        Returns the result of the following sum over all Siegert states</span>
<span class="sd">        :math:`varphi_S`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sum_S \frac{ \left\langle test | \varphi_S \right)</span>
<span class="sd">            \left( \varphi_S | test \right\rangle }</span>
<span class="sd">            {2 \left\langle test | test \right\rangle}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of (anti-)resonant states to use (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Evaluation of the completeness of the basis set using the</span>
<span class="sd">            Mittag-Leffler Expansion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_MLE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="p">,</span> <span class="s1">&#39;CR&#39;</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="n">nres</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_zero_operator"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_zero_operator">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_zero_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the value of the Mittag-Leffler Expansion of the zero</span>
<span class="sd">        operator using all Siegert states in the basis set for a given</span>
<span class="sd">        test function.</span>

<span class="sd">        Returns the result of the following sum over all Siegert states:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sum_S \frac{ \left\langle test | \varphi_S \right)</span>
<span class="sd">            \left( \varphi_S | test \right\rangle }</span>
<span class="sd">            { 2 k_S \left\langle test | test \right\rangle }</span>

<span class="sd">        where :math:`k_s` is the wavenumber of the Siegert state</span>
<span class="sd">        :math:`\varphi_S`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of (anti-)resonant states to use (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Evaluation of the zero operator of the basis set using the</span>
<span class="sd">            Mittag-Leffler Expansion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_MLE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="p">,</span> <span class="s1">&#39;Zero&#39;</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="n">nres</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_completeness"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_completeness">[docs]</a>    <span class="k">def</span> <span class="nf">exact_completeness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the exact completeness relation using the bound states</span>
<span class="sd">        of the basis set and the continuum states defined by either</span>
<span class="sd">        `hk` and `kmax` (respectively the grid-step and</span>
<span class="sd">        maximum wavenumber of the grid of continuum states) or all the</span>
<span class="sd">        continuum states in the basis set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        hk: float</span>
<span class="sd">            Grid step for the wavenumbers of the &quot;on-the-fly&quot; continuum</span>
<span class="sd">            basis sets (optional).</span>
<span class="sd">        kmax: float</span>
<span class="sd">            Maximal wavenumber of the &quot;on-the-fly&quot; continuum basis set</span>
<span class="sd">            (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Value of the exact completeness relation, using bound and</span>
<span class="sd">            continuum states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Bound states contribution to the exact CR</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">bnds_contrib</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bnds</span><span class="o">.</span><span class="n">MLE_completeness</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="c1"># Continuum states contribution to the CR: this is computed</span>
        <span class="c1"># through an integration of the sum of even and odd continuum</span>
        <span class="c1"># states contributions for each wavenumber of the grid.</span>
        <span class="n">kgrid</span><span class="p">,</span> <span class="n">integrand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="n">hk</span><span class="p">,</span>
                                                              <span class="n">kmax</span><span class="o">=</span><span class="n">kmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hk</span> <span class="o">=</span> <span class="n">kgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cont_contribs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">hk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bnds_contrib</span> <span class="o">+</span> <span class="n">cont_contribs</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.continuum_contributions_to_CR"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.continuum_contributions_to_CR">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">continuum_contributions_to_CR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover  # noqa</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an asbtract class method.</span>

<span class="sd">        Evaluate the continuum contributions to the completeness</span>
<span class="sd">        relation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        hk: float</span>
<span class="sd">            Grid step for the wavenumbers of the &quot;on-the-fly&quot; continuum</span>
<span class="sd">            basis sets (optional).</span>
<span class="sd">        kmax: float</span>
<span class="sd">            Maximal wavenumber of the &quot;on-the-fly&quot; continuum basis set</span>
<span class="sd">            (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Contribution of each continuum state of the basis set to the</span>
<span class="sd">            exact completeness relation.</span>
<span class="sd">        r&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_completeness_convergence"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_completeness_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_completeness_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the convergence of the Mittag-Leffler Expansion of the</span>
<span class="sd">        completeness relation for the basis set, given a test</span>
<span class="sd">        function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of (anti-)resonant states to use (default: use all of</span>
<span class="sd">            them).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(numpy array, numpy array)</span>
<span class="sd">            Two arrays of the same length. The first one is made of the</span>
<span class="sd">            absolute value of the resonant wavenumbers, while the second</span>
<span class="sd">            one is made of the values of the convergence of the MLE of</span>
<span class="sd">            the completeness relation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_MLE_convergence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="p">,</span> <span class="s1">&#39;CR&#39;</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="n">nres</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.Berggren_completeness_convergence"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.Berggren_completeness_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">Berggren_completeness_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the convergence of the CR using the Berggren expansion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of resonant states to use (default: use all of them).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(numpy array, numpy array)</span>
<span class="sd">            Two arrays of the same length. The first one is made of the</span>
<span class="sd">            absolute value of the resonant wavenumbers, while the second</span>
<span class="sd">            one is made of the values of the convergence of the Berggren</span>
<span class="sd">            expansion of the completeness relation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Keep only the required number of resonant states</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonants</span>
        <span class="k">if</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_states</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
        <span class="c1"># Find the bound and resonant states contributions to the CR</span>
        <span class="n">bnds_contrib</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">MLE_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">res_contrib</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">res</span><span class="o">.</span><span class="n">MLE_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="c1"># Create the output values as usual</span>
        <span class="n">kgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">wavenumbers</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">CR_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bnds_contrib</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">res_contrib</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">CR_conv</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_zero_operator_convergence"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_zero_operator_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_zero_operator_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the convergence of the Mittag-Leffler Expansion of the</span>
<span class="sd">        zero operator for the basis set, given a test function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of (anti-)resonant states to use (default: use all of</span>
<span class="sd">            them).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(numpy array, numpy array)</span>
<span class="sd">            Two arrays of the same length. The first one is made of the</span>
<span class="sd">            absolute value of the resonant wavenumbers, while the second</span>
<span class="sd">            one is made of the values of the convergence of the MLE of</span>
<span class="sd">            the zero operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_MLE_convergence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="p">,</span> <span class="s1">&#39;Zero&#39;</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="n">nres</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_completeness_convergence"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_completeness_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">exact_completeness_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the convergence of the exact completeness relation</span>
<span class="sd">        (using the continuum and bound states of the basis set) for a</span>
<span class="sd">        given test function.</span>

<span class="sd">        A set of continuum states is defined on-the-fly if the values</span>
<span class="sd">        of both ``hk`` and ``kmax`` are not ``None`` (otherwise,</span>
<span class="sd">        the continuum states of the basis set, if any, are used).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        hk: float</span>
<span class="sd">            Grid step for the wavenumbers of the &quot;on-the-fly&quot; continuum</span>
<span class="sd">            basis sets (optional).</span>
<span class="sd">        kmax: float</span>
<span class="sd">            Maximal wavenumber of the &quot;on-the-fly&quot; continuum basis set</span>
<span class="sd">            (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple(numpy array, numpy array)</span>
<span class="sd">            Two arrays of the same length. The first one is made of the</span>
<span class="sd">            continuum wavenumbers, while the second is made of the</span>
<span class="sd">            values of the convergence of the exact completeness</span>
<span class="sd">            relation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Bound states contribution to the exact CR</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">bnds_contrib</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bnds</span><span class="o">.</span><span class="n">MLE_completeness</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="c1"># Convergence of the continuum contribution to the CR</span>
        <span class="n">kgrid</span><span class="p">,</span> <span class="n">cont_contribs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continuum_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="n">hk</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="n">kmax</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hk</span> <span class="o">=</span> <span class="n">kgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">conv_cont_contribs</span> <span class="o">=</span> <span class="n">hk</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">cont_contribs</span><span class="p">)</span> <span class="o">-</span> <span class="n">cont_contribs</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
        <span class="c1"># Sum both bound and continuum states contributions to the exact CR</span>
        <span class="n">conv_CR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">conv_cont_contribs</span> <span class="o">+</span> <span class="n">bnds_contrib</span><span class="p">)</span>
        <span class="c1"># Return the convergence of the completeness relation</span>
        <span class="k">return</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">conv_CR</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.plot_completeness_convergence"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.plot_completeness_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">plot_completeness_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">MLE</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                      <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover  # noqa</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the convergence of both the Mittag-Leffler Expansion and</span>
<span class="sd">        the exact completeness relation for a given test function.</span>

<span class="sd">        The exact convergence is computed on-the-fly (*i.e.* without</span>
<span class="sd">        the need to have continuum states in the basis set):</span>

<span class="sd">        * if ``hk`` and ``kmax`` are not ``None``,</span>

<span class="sd">        * if ``exact`` and ``MLE`` are set to ``True`` and if</span>
<span class="sd">          the basis set does not contain enough continuum states to</span>
<span class="sd">          reach the absolute value of the last resonant wavenumber used</span>
<span class="sd">          (``kmax`` is therefore defined by the wavenumber of the</span>
<span class="sd">          last resonant state used in the MLE of the CR, and ``hk``</span>
<span class="sd">          is set to a default value)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        hk: float</span>
<span class="sd">            Grid step for the wavenumbers of the &quot;on-the-fly&quot; continuum</span>
<span class="sd">            basis sets (optional).</span>
<span class="sd">        kmax: float</span>
<span class="sd">            Maximal wavenumber of the &quot;on-the-fly&quot; continuum basis set</span>
<span class="sd">            (optional).</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of resonant couples contributions to be plotted</span>
<span class="sd">            (optional).</span>
<span class="sd">        exact: bool</span>
<span class="sd">            If ``True``, allows the plot of the exact strength function.</span>
<span class="sd">        MLE: bool</span>
<span class="sd">            If ``True``, allows the plot of the Mittag-Leffler Expansion</span>
<span class="sd">            of the strength function.</span>
<span class="sd">        title: str</span>
<span class="sd">            Plot title (optional).</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Filename of the plot to be saved (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Object-oriented plots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">init_plot</span><span class="p">()</span>
        <span class="c1"># Plot the expected value of 1</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="c1"># Set some initial values</span>
        <span class="k">if</span> <span class="n">MLE</span><span class="p">:</span>
            <span class="c1"># Evaluate the convergence of the MLE of the CR</span>
            <span class="n">abs_kres</span><span class="p">,</span> <span class="n">MLE_CR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MLE_completeness_convergence</span><span class="p">(</span><span class="n">test</span><span class="p">,</span>
                                                                 <span class="n">nres</span><span class="o">=</span><span class="n">nres</span><span class="p">)</span>
            <span class="c1"># Define if the parameters for the on-the-fly creation of</span>
            <span class="c1"># the continuum states have to be initialized</span>
            <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
                <span class="c1"># OTF is a Boolean stating if the continuum has to be</span>
                <span class="c1"># defined on-the-fly, given the input parameters</span>
                <span class="n">OTF</span> <span class="o">=</span> <span class="p">(</span><span class="n">hk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">OTF</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">or</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">wavenumber</span> <span class="o">&lt;</span> <span class="n">abs_kres</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">kmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">kmax</span> <span class="o">=</span> <span class="n">abs_kres</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">hk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">hk</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
            <span class="c1"># Evaluate and plot the convergence of the exact CR</span>
            <span class="n">kgrid</span><span class="p">,</span> <span class="n">exact_CR</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">exact_completeness_convergence</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="n">hk</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="n">kmax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">exact_CR</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#d73027&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Exact&#39;</span><span class="p">)</span>
        <span class="c1"># Plot the convergence of the MLE of the CR above the</span>
        <span class="c1"># convergence of the exact CR</span>
        <span class="k">if</span> <span class="n">MLE</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abs_kres</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">MLE_CR</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#4575b4&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;MLE&#39;</span><span class="p">,</span>
                    <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="c1"># Finalize the plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">MLE</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exact</span><span class="p">:</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;$CR_</span><span class="si">{MLE}</span><span class="s2">$&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;$CR$&quot;</span>
        <span class="n">finalize_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="o">=</span><span class="n">file_save</span><span class="p">,</span>
                      <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;$k$&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_strength_function"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_strength_function">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_strength_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the Mittag-Leffler expansion of the strength function</span>
<span class="sd">        for a given test function. The test function is discretized on</span>
<span class="sd">        a grid of wavenumbers ``kgrid``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        kgrid: numpy array</span>
<span class="sd">            Wavenumbers for which the strength function is evaluated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            MLE of the strength function evaluated over the wavenumber</span>
<span class="sd">            grid ``kgrid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize stren_func</span>
        <span class="n">stren_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">kgrid</span><span class="p">)</span>
        <span class="c1"># Loop over the siegert states to update the MLE of the RF</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="p">:</span>
            <span class="n">stren_func</span> <span class="o">+=</span> <span class="n">state</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stren_func</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_strength_function"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_strength_function">[docs]</a>    <span class="k">def</span> <span class="nf">exact_strength_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the exact strength function over a given wavenumber</span>
<span class="sd">        grid ``kgrid`` for a given a test function.</span>

<span class="sd">        ``eta`` is an infinitesimal used to make the integration over</span>
<span class="sd">        the continuum states possible (the poles along the real axis</span>
<span class="sd">        being avoided).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        kgrid: numpy array</span>
<span class="sd">            Wavenumbers for which the strength function is evaluated.</span>
<span class="sd">        eta: float</span>
<span class="sd">            Infinitesimal for integration (if ``None``, default to 10</span>
<span class="sd">            times the value of the grid-step of the continuum basis</span>
<span class="sd">            set).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Exact strength function evaluated on the grid of wavenumbers</span>
<span class="sd">            ``kgrid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Applying the method continuum_contributions_to_CR gives:</span>
        <span class="c1"># sum_p |&lt;test|varphi_p&gt;|**2 / &lt;test|test&gt;</span>
        <span class="c1"># for each continuum wavenumber. We actually want:</span>
        <span class="c1"># sum_p |&lt;test|varphi_p&gt;|**2</span>
        <span class="c1"># so we need to multiply by the norm &lt;test|test&gt;.</span>
        <span class="n">qgrid</span><span class="p">,</span> <span class="n">cont_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">cont_values</span> <span class="o">*=</span> <span class="n">test</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="c1"># Grid-step for integration</span>
        <span class="n">h_q</span> <span class="o">=</span> <span class="n">qgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">qgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Define the value of eta</span>
        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">h_q</span>
        <span class="c1"># Integrand for each k in kgrid (the imaginary part is already</span>
        <span class="c1"># taken into account, and eta is a parameter used to avoid</span>
        <span class="c1"># poles during the integration over the real wavenumber axis).</span>
        <span class="n">integrands</span> <span class="o">=</span> <span class="p">[</span><span class="n">eta</span> <span class="o">*</span> <span class="n">cont_values</span> <span class="o">/</span> <span class="p">((</span><span class="n">qgrid</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">2.</span><span class="o">-</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kgrid</span><span class="p">]</span>
        <span class="c1"># strength function (after integration of each integrand)</span>
        <span class="n">stren_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">h_q</span><span class="p">)</span> <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">integrands</span><span class="p">])</span>
        <span class="n">stren_func</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="n">stren_func</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_strength_function_OTF"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_strength_function_OTF">[docs]</a>    <span class="k">def</span> <span class="nf">exact_strength_function_OTF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">tol</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the exact strength function &quot;on-the-fly&quot; over a given</span>
<span class="sd">        wavenumber grid ``kgrid`` for a given a test function.</span>

<span class="sd">        It is not necessary to have continuum states in the basis set to</span>
<span class="sd">        compute the exact strength function, because they can be</span>
<span class="sd">        computed &quot;on-the-fly&quot; (hence OTF). This even leads to a quicker</span>
<span class="sd">        evaluation of the strength function because the integral, to be</span>
<span class="sd">        compute for each point of ``kgrid``, actually has an integrand</span>
<span class="sd">        that peaks around each particular value of ``kgrid`` and quickly</span>
<span class="sd">        vanishes around its maximum.</span>

<span class="sd">        Such a minimal approximated integrand is constructed by using</span>
<span class="sd">        only the continuum states aroud the point of the ``kgrid``</span>
<span class="sd">        considered, given the tolerance parameter tol.</span>
<span class="sd">        It allows to reach smaller values of ``hk`` and ``eta``, and</span>
<span class="sd">        therefore more precise results, in a shorter amount of time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        kgrid: numpy array</span>
<span class="sd">            Wavenumbers for which the strength function is evaluated.</span>
<span class="sd">        hk: float</span>
<span class="sd">            Grid step for the wavenumbers of the &quot;on-the-fly&quot; continuum</span>
<span class="sd">            basis sets (optional).</span>
<span class="sd">        eta: float</span>
<span class="sd">            Infinitesimal for integration (if ``None``, default to 10</span>
<span class="sd">            times the value of the grid-step of the continuum basis</span>
<span class="sd">            set).</span>
<span class="sd">        tol: float</span>
<span class="sd">            Tolerance value to truncate the integrand function (ratio of</span>
<span class="sd">            the value of a possible new point of the integrand to the</span>
<span class="sd">            maximal value of the integrand).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Approximate exact strength function evaluated on the grid of</span>
<span class="sd">            wavenumbers ``kgrid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set initial variables</span>
        <span class="n">stren_func</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">hk</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span>
        <span class="c1"># Loop over points in kgrid</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kgrid</span><span class="p">:</span>
            <span class="c1"># Build the integrand:</span>
            <span class="c1"># - initialize</span>
            <span class="n">integrand_m</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">integrand_p</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_integrand</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">pot</span><span class="p">)</span>
            <span class="n">q_m</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">q_p</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">new_int_m</span> <span class="o">=</span> <span class="n">first</span>
            <span class="n">new_int_p</span> <span class="o">=</span> <span class="n">first</span>
            <span class="c1"># - find new terms while necessary</span>
            <span class="k">while</span> <span class="n">new_int_m</span> <span class="o">/</span> <span class="n">first</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">q_m</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">q_m</span> <span class="o">=</span> <span class="n">q_m</span> <span class="o">-</span> <span class="n">hk</span>
                <span class="n">new_int_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_integrand</span><span class="p">(</span><span class="n">q_m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">pot</span><span class="p">)</span>
                <span class="n">integrand_m</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_int_m</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">new_int_p</span> <span class="o">/</span> <span class="n">first</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">q_p</span> <span class="o">=</span> <span class="n">q_p</span> <span class="o">+</span> <span class="n">hk</span>
                <span class="n">new_int_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_integrand</span><span class="p">(</span><span class="n">q_p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">pot</span><span class="p">)</span>
                <span class="n">integrand_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_int_p</span><span class="p">)</span>
            <span class="c1"># - assemble the whole integrand function</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">integrand_m</span> <span class="o">+</span> <span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">+</span> <span class="n">integrand_p</span>
            <span class="c1"># Do the integral, and append the result to stren_func</span>
            <span class="n">stren_func</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">hk</span><span class="p">))</span>
        <span class="c1"># Return the correctly normalized strength function as an array</span>
        <span class="n">stren_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stren_func</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="n">stren_func</span></div>

<div class="viewcode-block" id="AnalyticBasisSet._evaluate_integrand"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet._evaluate_integrand">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_evaluate_integrand</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">potential</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an asbtract class method.</span>

<span class="sd">        Evaluate the integrand used to compute the strength function</span>
<span class="sd">        &quot;on-the-fly&quot;. It must be implemented in the child class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q: float</span>
<span class="sd">            Wavenumber of the continuum state considered.</span>
<span class="sd">        k: float</span>
<span class="sd">            Wavenumber for which the strength function is evaluated.</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        eta: float</span>
<span class="sd">            Infinitesimal for integration (if ``None``, default to 10</span>
<span class="sd">            times the value of the grid-step of the continuum basis</span>
<span class="sd">            set).</span>
<span class="sd">        potential: Potential</span>
<span class="sd">            Potential of the currently studied analytical case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.plot_strength_function"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.plot_strength_function">[docs]</a>    <span class="k">def</span> <span class="nf">plot_strength_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">MLE</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bnds_abnds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the convergence of both the Mittag-Leffler Expansion and</span>
<span class="sd">        the exact strength function for a given test function.</span>

<span class="sd">        The exact convergence is computed on-the-fly (without the need</span>
<span class="sd">        to have continuum states in the BasisSet self).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        kgrid: numpy array</span>
<span class="sd">            Wavenumbers for which the strength function is evaluated.</span>
<span class="sd">        nres: int</span>
<span class="sd">            Number of resonant couples contributions to be plotted</span>
<span class="sd">            (default to None, meaning that none are plotted; if</span>
<span class="sd">            ``nres=0``, then only the sum of the bound and anti-bound</span>
<span class="sd">            states contributions is plotted).</span>
<span class="sd">        exact: bool</span>
<span class="sd">            If ``True``, allows the plot of the exact strength function.</span>
<span class="sd">        MLE: bool</span>
<span class="sd">            If ``True``, allows the plot of the Mittag-Leffler Expansion</span>
<span class="sd">            of the strength function.</span>
<span class="sd">        bnds_abnds: bool</span>
<span class="sd">            If ``True``, allows to plot the individual contributions of</span>
<span class="sd">            the bound and anti-bound states.</span>
<span class="sd">        title: str</span>
<span class="sd">            Plot title (optional).</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Filename of the plot to be saved (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Object-oriented plots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">init_plot</span><span class="p">()</span>
        <span class="c1"># set initial values</span>
        <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
            <span class="c1"># Evaluate and plot the convergence of the exact strength</span>
            <span class="c1"># function, continuum states being computed on-the-fly.</span>
            <span class="n">exact_SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact_strength_function_OTF</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">exact_SF</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#d73027&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Exact&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">MLE</span><span class="p">:</span>
            <span class="c1"># Evaluate and plot the MLE of the SF</span>
            <span class="n">MLE_SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">MLE_SF</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000000&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;MLE&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Plot the contribution of the bound and anti-bound states</span>
            <span class="c1"># to the strength function</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">antibounds</span>
            <span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#b2182b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;b+ab&quot;</span><span class="p">)</span>
            <span class="c1"># Plot the contribution of the nres first resonance couples</span>
            <span class="c1"># to the strength function</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonants</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
            <span class="n">ares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiresonants</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nres</span><span class="p">):</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span> <span class="o">+</span>
                      <span class="n">ares</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">))</span>
                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$N_</span><span class="si">{res}</span><span class="s2"> = $&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="c1"># Plot the contribution of each bound and antibound</span>
        <span class="c1"># states to the MLE of the strength function.</span>
        <span class="k">if</span> <span class="n">bnds_abnds</span><span class="p">:</span>
            <span class="n">bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">bnds</span><span class="p">:</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#FF0000&#39;</span><span class="p">)</span>
            <span class="n">abnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antibounds</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">abnds</span><span class="p">:</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">MLE_strength_function</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">kgrid</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kgrid</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#660000&#39;</span><span class="p">)</span>
        <span class="c1"># Finalize the plot</span>
        <span class="k">if</span> <span class="n">MLE</span> <span class="ow">or</span> <span class="n">exact</span><span class="p">:</span>
            <span class="c1"># If resonant contributions, place the legends on the right</span>
            <span class="k">if</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nres</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">leg_loc</span><span class="p">,</span> <span class="n">leg_bbox_to_anchor</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="c1"># Else, place the legends on the default location</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">leg_loc</span><span class="p">,</span> <span class="n">leg_bbox_to_anchor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">finalize_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="o">=</span><span class="n">file_save</span><span class="p">,</span>
                      <span class="n">leg_loc</span><span class="o">=</span><span class="n">leg_loc</span><span class="p">,</span> <span class="n">leg_bbox_to_anchor</span><span class="o">=</span><span class="n">leg_bbox_to_anchor</span><span class="p">,</span>
                      <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;$k$&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;$S(k)$&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_propagation"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">exact_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the exact time-propagation of a wavepacket ``test``</span>
<span class="sd">        over a given time grid (made of positive numbers only).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array</span>
<span class="sd">            Exact propagated wavepacket for the different times of</span>
<span class="sd">            ``time_grid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate separately the contribution of the continuum states</span>
        <span class="c1"># and of the bound states to the time propagation of the</span>
        <span class="c1"># wavepacket and finally sum them.</span>
        <span class="n">cont_contrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="o">.</span><span class="n">_propagate</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="n">bnds_contrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">Siegert_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span>
                                                       <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">cont_contrib</span> <span class="o">+</span> <span class="n">bnds_contrib</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_propagation_OTF"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_propagation_OTF">[docs]</a>    <span class="k">def</span> <span class="nf">exact_propagation_OTF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">hk</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the exact time-propagation of a given test function</span>
<span class="sd">        for a given time grid after an on-the-fly creation of the</span>
<span class="sd">        continuum states given the values of ``kmax`` and ``hk``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>
<span class="sd">        hk: float</span>
<span class="sd">            Grid step for the wavenumbers of the &quot;on-the-fly&quot; continuum</span>
<span class="sd">            basis sets (optional).</span>
<span class="sd">        kmax: float</span>
<span class="sd">            Maximal wavenumber of the &quot;on-the-fly&quot; continuum basis set</span>
<span class="sd">            (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :returns: Exact propagated wavepacket for the different times</span>
<span class="sd">            of ``time_grid``.</span>
<span class="sd">        :rtype: 2D numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span>
        <span class="n">xgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">find_continuum_states</span><span class="p">(</span><span class="n">pot</span><span class="p">,</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">hk</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">xgrid</span><span class="p">)</span>
        <span class="n">exact</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="n">cont</span>
        <span class="k">return</span> <span class="n">exact</span><span class="o">.</span><span class="n">exact_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.MLE_propagation"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.MLE_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">MLE_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the Mittag-Leffler Expansion of the time-propagation of</span>
<span class="sd">        a test wavepacket over a given time grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array</span>
<span class="sd">            MLE of the propagated wavepacket for the different times of</span>
<span class="sd">            ``time_grid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The Mittag-Leffler expansions consists in using all Siegert</span>
        <span class="c1"># states with a 0.5 weight</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Siegert_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span>
                                        <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;ab&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
                                                 <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">})</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.Berggren_propagation"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.Berggren_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">Berggren_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the Berggren Expansion of the time-propagation of a</span>
<span class="sd">        test wavepacket over a given time grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array</span>
<span class="sd">            Berggren expansion of the propagated wavepacket for the</span>
<span class="sd">            different times of ``time_grid``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The Berggren expansion consists in using the bound and</span>
        <span class="c1"># resonant states only (with a weight 1).</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Siegert_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span>
                                        <span class="n">weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.Siegert_propagation"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.Siegert_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">Siegert_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a user-defined expansion over the Siegert states of the</span>
<span class="sd">        time-propagation of a test wavepacket over a given time grid.</span>

<span class="sd">        The user chooses the weight of each type of Siegert states of</span>
<span class="sd">        the basis set. If no weights are passed, then exact Siegert</span>
<span class="sd">        states expansion is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>
<span class="sd">        weights: dict</span>
<span class="sd">            Dictionary of the weights to use for the time-propagation.</span>
<span class="sd">            Keys correspond to a type of Siegert states (&#39;ab&#39; for</span>
<span class="sd">            anti-bounds, &#39;b&#39; for bounds, &#39;r&#39; for resonants and &#39;ar&#39; for</span>
<span class="sd">            anti-resonants) and the corresponding value is the weight to</span>
<span class="sd">            use for all the states of the given type (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array</span>
<span class="sd">            Siegert states expansion of the propagated wavepacket for</span>
<span class="sd">            the different times of ``time_grid``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If an invalid key is found in ``weights``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a weight dictionary is given, then propagate accordingly,</span>
        <span class="c1"># without using the Faddeeva function</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check that weights has valid keys</span>
            <span class="k">for</span> <span class="n">S_type</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">S_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIEGERT_STATES_TYPES</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Invalid key </span><span class="si">{}</span><span class="s2"> in the dictionary of &quot;</span>
                                   <span class="s2">&quot;weights. The keys must be a subset of &quot;</span>
                                   <span class="s2">&quot;(&#39;ab&#39;, &#39;b&#39;, &#39;r&#39;, &#39;ar&#39;).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S_type</span><span class="p">))</span>
            <span class="c1"># Create 0 values for the missing Siegert types</span>
            <span class="k">for</span> <span class="n">S_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIEGERT_STATES_TYPES</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">S_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">S_type</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># Propagate the wavepacket according to the weights</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="o">.</span><span class="n">_propagate</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="c1"># Else, if no weights are given, then perform the exact Siegert</span>
        <span class="c1"># expansion, using the Faddeeva function.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact_Siegert_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.exact_Siegert_propagation"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.exact_Siegert_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">exact_Siegert_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the exact Siegert propagation of the initial wavepacket</span>
<span class="sd">        test for the times of time_grid. In contrast with all other</span>
<span class="sd">        expansions for the propagation, the time-evolution of the</span>
<span class="sd">        Siegert states is not only due to an exponential, but also to</span>
<span class="sd">        state- and time-dependent weights (see eq. 69 of Santra et al.,</span>
<span class="sd">        PRA 71 (2005)).</span>

<span class="sd">        There is no need to define any weight, since the correct weight</span>
<span class="sd">        is known analytically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array</span>
<span class="sd">            Exact Siegert expansion of the propagated wavepacket for the</span>
<span class="sd">            different times of ``time_grid``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        BasisSetError</span>
<span class="sd">            If the basis set contains no Siegert states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the basis set is not empty.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BasisSetError</span><span class="p">(</span><span class="s2">&quot;The basis set must contain Siegert states&quot;</span><span class="p">)</span>
        <span class="c1"># Make sure that time_grid is made of positive numbers</span>
        <span class="c1"># and that t=0 is part of the time_grid</span>
        <span class="n">time_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_grid</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">time_grid</span><span class="p">)</span>
        <span class="c1"># Prepare the calculation by separating the states needing an</span>
        <span class="c1"># exponential term in the time propagation:</span>
        <span class="c1"># - states with exponential terms</span>
        <span class="n">basis_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">resonants</span>
        <span class="c1"># - states without exponential terms</span>
        <span class="n">basis_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antibounds</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiresonants</span>
        <span class="c1"># Prepare the weights accordingly</span>
        <span class="n">weights_1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">weights_2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ab&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="c1"># Evaluate the contribution of the states with the exponential</span>
        <span class="c1"># terms in the time_propagation</span>
        <span class="k">if</span> <span class="n">basis_1</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
            <span class="n">mat_space_1</span> <span class="o">=</span> <span class="n">_set_mat_space_S</span><span class="p">(</span><span class="n">basis_1</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">weights_1</span><span class="p">)</span>
            <span class="n">mat_time_1</span> <span class="o">=</span> <span class="n">_set_mat_time_S</span><span class="p">(</span><span class="n">basis_1</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">with_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mat_prop</span> <span class="o">=</span> <span class="n">mat_time_1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_space_1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat_prop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Evaluate the other contributions to the exact Siegert</span>
        <span class="c1"># propagation and add them to the first matrix</span>
        <span class="k">if</span> <span class="n">basis_2</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
            <span class="n">mat_space_2</span> <span class="o">=</span> <span class="n">_set_mat_space_S</span><span class="p">(</span><span class="n">basis_2</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">weights_2</span><span class="p">)</span>
            <span class="n">mat_time_2</span> <span class="o">=</span> <span class="n">_set_mat_time_S</span><span class="p">(</span><span class="n">basis_2</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">with_exp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mat_prop</span> <span class="o">+=</span> <span class="n">mat_time_2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_space_2</span><span class="p">)</span>
        <span class="c1"># Return the exact</span>
        <span class="k">return</span> <span class="n">mat_prop</span></div>

<div class="viewcode-block" id="AnalyticBasisSet._propagate"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet._propagate">[docs]</a>    <span class="k">def</span> <span class="nf">_propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the time-propagation of a test wavepacket as the matrix</span>
<span class="sd">        product of two matrices: one to account for the time dependance</span>
<span class="sd">        of the propagation of the wavepacket (mat_time), the other for</span>
<span class="sd">        its space dependance (mat_space).</span>

<span class="sd">        The contribution of the continuum states to the time</span>
<span class="sd">        propagation of the wavepacket requires a numerical integration</span>
<span class="sd">        that is performed using the composite Simpson&#39;s rule.</span>

<span class="sd">        The contribution of the Siegert states to the time propagation</span>
<span class="sd">        of the wavepacket is computed through a discrete sum over all</span>
<span class="sd">        the Siegert states, with a user-defined weight for each type</span>
<span class="sd">        of Siegert states.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>
<span class="sd">        weights: dict</span>
<span class="sd">            Dictionary of the weights to use for the time-propagation.</span>
<span class="sd">            Keys correspond to a type of Siegert states (&#39;ab&#39; for</span>
<span class="sd">            anti-bounds, &#39;b&#39; for bounds, &#39;r&#39; for resonants and &#39;ar&#39; for</span>
<span class="sd">            anti-resonants) and the corresponding value is the weight to</span>
<span class="sd">            use for all the states of the given type (optional).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2D numpy array</span>
<span class="sd">            Propagated wavepacket for the different times of</span>
<span class="sd">            ``time_grid``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        BasisSetError</span>
<span class="sd">            If the basis set does not contain Siegert nor continuum</span>
<span class="sd">            states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that there are states to be used</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="p">)</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BasisSetError</span><span class="p">(</span><span class="s2">&quot;The basis set must not be empty&quot;</span><span class="p">)</span>
        <span class="c1"># Make sure that time_grid is made of positive numbers</span>
        <span class="c1"># and that t=0 is part of the time_grid</span>
        <span class="n">time_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_grid</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">time_grid</span><span class="p">)</span>
        <span class="c1"># Find the Siegert states contribution to the time propagation</span>
        <span class="n">mat_prop_S</span> <span class="o">=</span> <span class="n">_propagate_over_Siegerts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span>
                                              <span class="n">weights</span><span class="p">)</span>
        <span class="c1"># Find the continuum states contribution to the time propagation</span>
        <span class="n">mat_prop_c</span> <span class="o">=</span> <span class="n">_propagate_over_continuum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="c1"># Add both contributions</span>
        <span class="k">return</span> <span class="n">mat_prop_S</span> <span class="o">+</span> <span class="n">mat_prop_c</span></div>
        <span class="c1"># return prop #TODO: list of functions (with time as attribute?)</span>

<div class="viewcode-block" id="AnalyticBasisSet._add_one_continuum_state"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet._add_one_continuum_state">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_add_one_continuum_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an asbtract class method.</span>

<span class="sd">        Add a continuum state to the basis set, depending on the already</span>
<span class="sd">        existing continuum states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AnalyticBasisSet</span>
<span class="sd">            Instance of the child class with one more continuum state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="AnalyticBasisSet.plot_propagation"><a class="viewcode-back" href="../../AnalyticBasisSet.html#siegpy.analyticbasisset.AnalyticBasisSet.plot_propagation">[docs]</a>    <span class="k">def</span> <span class="nf">plot_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exact_Siegert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">MLE</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Berggren</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the time propagation of a wavepacket using either the exact</span>
<span class="sd">        expansion (using bound and continuum states), the exact Siegert</span>
<span class="sd">        states expansion, the Mittag-Leffler Expansion or the Berggren</span>
<span class="sd">        expansion over a given time grid.</span>

<span class="sd">        Any of these expansions can be turned on or off by setting the</span>
<span class="sd">        corresponding optional arguments (``exact``, ``exact_Siegert``,</span>
<span class="sd">        ``MLE`` and ``Berggren`` respectively) to ``True`` or ``False``.</span>
<span class="sd">        By default, both exact expansions are plotted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        test: Function</span>
<span class="sd">            Test function.</span>
<span class="sd">        time_grid: numpy array or list of positive numbers</span>
<span class="sd">            Times for which the propagation is evaluated. It must</span>
<span class="sd">            contain positive numbers only.</span>
<span class="sd">        exact: bool</span>
<span class="sd">            If ``True``, allows the plot of the exact time-propagation</span>
<span class="sd">            (using bound and continuum states).</span>
<span class="sd">        exact_Siegert: bool</span>
<span class="sd">            If ``True``, allows the plot of the exact time-propagation</span>
<span class="sd">            (using all Siegert states).</span>
<span class="sd">        MLE: bool</span>
<span class="sd">            If ``True``, allows the plot of the Mittag-Leffler Expansion</span>
<span class="sd">            of the time-propagation.</span>
<span class="sd">        Berggren: bool</span>
<span class="sd">            If ``True``, allows the plot of the Berggren expansion of</span>
<span class="sd">            the time-propagation.</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the x axis of the plot (optional).</span>
<span class="sd">        xlim: tuple(float or int, float or int)</span>
<span class="sd">            Range of the y axis of the plot (optional).</span>
<span class="sd">        title: str</span>
<span class="sd">            Plot title (optional).</span>
<span class="sd">        file_save: str</span>
<span class="sd">            Base name of the files where the plots are to be saved</span>
<span class="sd">            (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate the various time-propagation expansions required</span>
        <span class="k">if</span> <span class="n">exact</span><span class="p">:</span>
            <span class="c1"># Evaluate and plot the convergence of the exact</span>
            <span class="c1"># time-propagation.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuum</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="c1"># Create continuum states on-the-fly</span>
                <span class="n">kmax</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resonants</span><span class="o">.</span><span class="n">wavenumbers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">exact_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact_propagation_OTF</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span>
                                                      <span class="n">kmax</span><span class="p">,</span> <span class="n">hk</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exact_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exact_tp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">exact_Siegert</span><span class="p">:</span>
            <span class="c1"># Evaluate and plot the convergence of the exact</span>
            <span class="c1"># Siegert time-propagation.</span>
            <span class="n">exact_S_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact_Siegert_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exact_S_tp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">MLE</span><span class="p">:</span>
            <span class="c1"># Evaluate and plot the MLE of the time-propagation</span>
            <span class="n">MLE_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MLE_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MLE_tp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">Berggren</span><span class="p">:</span>
            <span class="c1"># Evaluate the Berggren expansion of the time-propagation</span>
            <span class="n">Ber_tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Berggren_propagation</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ber_tp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_generate_time_plots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">exact_tp</span><span class="p">,</span> <span class="n">exact_S_tp</span><span class="p">,</span>
                             <span class="n">MLE_tp</span><span class="p">,</span> <span class="n">Ber_tp</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_complex_plane_plot</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="p">):</span>  <span class="c1"># pragma: no cover  # noqa</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot either the wavenumber or the energy of each Siegert state in</span>
<span class="sd">    the basis set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    states: list</span>
<span class="sd">        States of the basis set to be plotted.</span>
<span class="sd">    attr: str</span>
<span class="sd">        Name of the eigenstate attribute to look for, defining the type</span>
<span class="sd">        of plot to be done.</span>
<span class="sd">    xlim: tuple(float or int, float or int)</span>
<span class="sd">        Range of the x axis of the plot (optional).</span>
<span class="sd">    ylim: tuple(float or int, float or int)</span>
<span class="sd">        Range of the y axis of the plot (optional).</span>
<span class="sd">    title: str</span>
<span class="sd">        Plot title (optional).</span>
<span class="sd">    file_save: str</span>
<span class="sd">        Filename of the plot to be saved (optional).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Object-oriented plots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">init_plot</span><span class="p">()</span>
    <span class="c1"># Add the real and imaginary axes</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># black line y=0</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># black line x=0</span>
    <span class="c1"># Get the data to be plotted thanks to the name of the attribute</span>
    <span class="n">plot_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">S_type</span> <span class="ow">in</span> <span class="n">BasisSet</span><span class="o">.</span><span class="n">STATES_TYPES</span><span class="p">:</span>
        <span class="n">plot_data</span><span class="p">[</span><span class="n">S_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span>
                             <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">Siegert_type</span> <span class="o">==</span> <span class="n">S_type</span><span class="p">]</span>
    <span class="c1"># Plot the data for each type of states</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ab&#39;</span><span class="p">:</span> <span class="s1">&#39;Anti-bounds&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;Bounds&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;Resonants&#39;</span><span class="p">,</span>
              <span class="s1">&#39;ar&#39;</span><span class="p">:</span> <span class="s1">&#39;Anti-resonants&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">:</span> <span class="s1">&#39;Continuum&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">}</span>
    <span class="n">markers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ab&#39;</span><span class="p">:</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;ar&#39;</span><span class="p">:</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">:</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span>
               <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">}</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ab&#39;</span><span class="p">:</span> <span class="s1">&#39;#660000&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;#FF0000&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;#0000FF&#39;</span><span class="p">,</span>
              <span class="s1">&#39;ar&#39;</span><span class="p">:</span> <span class="s1">&#39;#000066&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">:</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;k&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">S_type</span> <span class="ow">in</span> <span class="n">BasisSet</span><span class="o">.</span><span class="n">STATES_TYPES</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">plot_data</span><span class="p">[</span><span class="n">S_type</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">plot_data</span><span class="p">[</span><span class="n">S_type</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">plot_data</span><span class="p">[</span><span class="n">S_type</span><span class="p">]),</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">S_type</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="n">markers</span><span class="p">[</span><span class="n">S_type</span><span class="p">],</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">S_type</span><span class="p">])</span>
    <span class="c1"># Set the base name of the x and y axis of the plot</span>
    <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;wavenumber&#39;</span><span class="p">:</span>
        <span class="n">data_label</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
    <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;energy&#39;</span><span class="p">:</span>
        <span class="n">data_label</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
    <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Re[$</span><span class="si">{}</span><span class="s2">$]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_label</span><span class="p">)</span>
    <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Im[$</span><span class="si">{}</span><span class="s2">$]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_label</span><span class="p">)</span>
    <span class="c1"># Finalize the plot</span>
    <span class="n">finalize_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">leg_loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                  <span class="n">file_save</span><span class="o">=</span><span class="n">file_save</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_MLE</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the Mittag-Leffler Expansion of an operator over all the</span>
<span class="sd">    Siegert states in the basis set as a sum of the contribution of each</span>
<span class="sd">    state.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    siegerts: AnalyticBasisSet</span>
<span class="sd">        Basis set made of Siegert states only.</span>
<span class="sd">    operator: str</span>
<span class="sd">        Name of the operator.</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>
<span class="sd">    nres: int</span>
<span class="sd">        Number of (anti-)resonant states to use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Evaluation of the operator on the whole the basis set using the</span>
<span class="sd">        Mittag-Leffler Expansion.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the name of the operator is not &#39;CR&#39; nor &#39;Zero&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Keep the required siegert states</span>
    <span class="k">if</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">siegerts</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">antibounds</span> \
            <span class="o">+</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">resonants</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span> <span class="o">+</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">antiresonants</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
    <span class="c1"># Define which MLE to obtain</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;CR&#39;</span><span class="p">:</span>  <span class="c1"># Completeness relation</span>
        <span class="n">contribs</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">MLE_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;Zero&#39;</span><span class="p">:</span>  <span class="c1"># Zero operator</span>
        <span class="n">contribs</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">MLE_contributions_to_zero_operator</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown operator </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="p">))</span>
    <span class="c1"># Return the cumulative sum of the values</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contribs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_MLE_convergence</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">nres</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the convergence of the Mittag-Leffler Expansion of an</span>
<span class="sd">    operator as a cumulative sum of the contributions of each</span>
<span class="sd">    resonant couple in the basis set.</span>

<span class="sd">    An initial value corresponding to the bound and anti-bound</span>
<span class="sd">    states contributions is added to all the resonant couples.</span>
<span class="sd">    It also corresponds to the first value of the second returned</span>
<span class="sd">    array.</span>

<span class="sd">    .. warning::</span>

<span class="sd">       It returns a tuple made of two arrays:</span>

<span class="sd">       * the first one corresponds to the wavenumbers where the</span>
<span class="sd">         convergence is evaluated (with 0 as the first element),</span>

<span class="sd">       * the second one corresponds to the convergence of the</span>
<span class="sd">         operator (the first element corresponding to the bound and</span>
<span class="sd">         anti-bound states contributions).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    siegerts: AnalyticBasisSet</span>
<span class="sd">        Basis set made of Siegert states only.</span>
<span class="sd">    operator: str</span>
<span class="sd">        Name of the operator.</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>
<span class="sd">    nres: int</span>
<span class="sd">        Number of (anti-)resonant states to use (default: use all of</span>
<span class="sd">        them).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple(numpy array, numpy array)</span>
<span class="sd">        Wavenumbers and convergence of the MLE of the operator on</span>
<span class="sd">        the whole the basis set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The initial value is the sum of the contribution</span>
    <span class="c1"># of bound and anti-bound states.</span>
    <span class="n">bnd_abnd</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">antibounds</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">_MLE</span><span class="p">(</span><span class="n">bnd_abnd</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
    <span class="c1"># Evaluate the cumulative sum of the contribution of each</span>
    <span class="c1"># resonant/anti-resonant couples contribution to the</span>
    <span class="c1"># completenes relation</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">resonants</span>
    <span class="n">ares</span> <span class="o">=</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">antiresonants</span>
    <span class="k">if</span> <span class="n">nres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_states</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
        <span class="n">ares</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="n">ares</span><span class="o">.</span><span class="n">_states</span><span class="p">[:</span><span class="n">nres</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;CR&#39;</span><span class="p">:</span>
        <span class="n">res_contribs</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">MLE_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">ares_contribs</span> <span class="o">=</span> <span class="n">ares</span><span class="o">.</span><span class="n">MLE_contributions_to_CR</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;Zero&#39;</span><span class="p">:</span>
        <span class="n">res_contribs</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">MLE_contributions_to_zero_operator</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
        <span class="n">ares_contribs</span> <span class="o">=</span> <span class="n">ares</span><span class="o">.</span><span class="n">MLE_contributions_to_zero_operator</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
    <span class="n">cum_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">res_contribs</span> <span class="o">+</span> <span class="n">ares_contribs</span><span class="p">)</span>
    <span class="c1"># Add a zero at the beginning in order to get the bound and</span>
    <span class="c1"># anti-bound states contributions as the first element of the</span>
    <span class="c1"># completeness relation array.</span>
    <span class="n">cum_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cum_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
    <span class="c1"># Create the completeness relation evolution list by adding the</span>
    <span class="c1"># initial value to all elements of cum_sum.</span>
    <span class="n">conv</span> <span class="o">=</span> <span class="n">cum_sum</span> <span class="o">+</span> <span class="n">init</span>
    <span class="c1"># Get the absolute value of resonant wavenumbers.</span>
    <span class="c1"># They will be used as the abscissa of the plot.</span>
    <span class="n">kgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">wavenumbers</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Return the array of values to plot (grid of wavenumbers and</span>
    <span class="c1"># convergence of the MLE of the operator)</span>
    <span class="k">return</span> <span class="n">kgrid</span><span class="p">,</span> <span class="n">conv</span>


<span class="k">def</span> <span class="nf">_continuum_contributions_to_CR</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the contribution of each continuum state of the basis set</span>
<span class="sd">    to the exact completeness relation.</span>

<span class="sd">    Note that the length of the returned array is equal to</span>
<span class="sd">    len(continuum) + 1, in order to account for the 0 contribution of</span>
<span class="sd">    the continuum state at k=0.</span>

<span class="sd">    Each element of the array is defined by:</span>
<span class="sd">    :math:`\sum_{p=+/-}</span>
<span class="sd">    \frac{| \left\langle test | \varphi_p \right\rangle |^2}</span>
<span class="sd">    {\left\langle test | test \right\rangle}`</span>
<span class="sd">    where :math:`\varphi` is a wavefunction of the basis set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>
<span class="sd">    continuum: BasisSet</span>
<span class="sd">        Basis set of continuum states (optional).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Contribution of each continuum state of the basis set to the</span>
<span class="sd">        exact completeness relation.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    BasisSetError</span>
<span class="sd">        If there are not enough continuum states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1- Check that there are enough continuum states available</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">continuum</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BasisSetError</span><span class="p">(</span>
            <span class="s2">&quot;There are not enough continuum states in the basis set.&quot;</span><span class="p">)</span>
    <span class="c1"># 2- Contribution of each continuum states</span>
    <span class="n">cont_contribs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">continuum</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="n">test</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cont_contribs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cont_contribs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">/</span> <span class="n">test</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
    <span class="c1"># 3- Get the grid of corresponding wavenumbers</span>
    <span class="n">kgrid</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">+</span> <span class="n">continuum</span><span class="o">.</span><span class="n">wavenumbers</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kgrid</span><span class="p">),</span> <span class="n">cont_contribs</span>


<span class="k">def</span> <span class="nf">_propagate_over_continuum</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the continuum states contributions to the time propagation</span>
<span class="sd">    of ``test`` for all the times in ``time_grid``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    continuum: AnalyticBasisSet</span>
<span class="sd">        Basis set made of continuum states only.</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>
<span class="sd">    time_grid: numpy array or list of positive numbers</span>
<span class="sd">        Times for which the propagation is evaluated. It must</span>
<span class="sd">        contain positive numbers only.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2D numpy array</span>
<span class="sd">        Continuum states contributions to the time propagation of</span>
<span class="sd">        ``test`` for all the times in ``time_grid``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If there are no continuum states, then they have no</span>
    <span class="c1"># contribution to the time propagation</span>
    <span class="k">if</span> <span class="n">continuum</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="n">mat_prop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Else, make sure that there are an odd number of continuum</span>
    <span class="c1"># states and compute their contribution to the time propagation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">continuum</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">continuum</span> <span class="o">=</span> <span class="n">continuum</span><span class="o">.</span><span class="n">_add_one_continuum_state</span><span class="p">()</span>
        <span class="n">mat_space</span> <span class="o">=</span> <span class="n">_set_mat_space_c</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
        <span class="n">mat_time</span> <span class="o">=</span> <span class="n">_set_mat_time</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="n">mat_prop</span> <span class="o">=</span> <span class="n">mat_time</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_space</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat_prop</span>


<span class="k">def</span> <span class="nf">_propagate_over_Siegerts</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the Siegert states contributions to the time</span>
<span class="sd">    propagation of ``test`` for all the times in ``time_grid``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    siegerts: AnalyticBasisSet</span>
<span class="sd">        Basis set made of Siegert states only.</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>
<span class="sd">    time_grid: numpy array or list of positive numbers</span>
<span class="sd">        Times for which the propagation is evaluated. It must</span>
<span class="sd">        contain positive numbers only.</span>
<span class="sd">    weights: dict</span>
<span class="sd">        Dictionary of the weights to use for the time-propagation.</span>
<span class="sd">        Keys correspond to a type of Siegert states (&#39;ab&#39; for</span>
<span class="sd">        anti-bounds, &#39;b&#39; for bounds, &#39;r&#39; for resonants and &#39;ar&#39; for</span>
<span class="sd">        anti-resonants) and the corresponding value is the weight to</span>
<span class="sd">        use for all the states of the given type (optional).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2D numpy array</span>
<span class="sd">        Siegert states contributions to the time propagation of</span>
<span class="sd">        ``test`` for all the times in ``time_grid``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no weights are passed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If there are no Siegert states, then they have no contribution</span>
    <span class="c1"># to the time propagation</span>
    <span class="k">if</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="n">mat_prop</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Else, compute their contribution to the time propagation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A dictionary of weights must be provided.&quot;</span><span class="p">)</span>
        <span class="n">mat_space</span> <span class="o">=</span> <span class="n">_set_mat_space_S</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">mat_time</span> <span class="o">=</span> <span class="n">_set_mat_time</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="n">mat_prop</span> <span class="o">=</span> <span class="n">mat_time</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_space</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat_prop</span>


<span class="k">def</span> <span class="nf">_set_mat_time_S</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">with_exp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the mat_time matrix based on the Siegert states. This</span>
<span class="sd">    matrix can then be used to compute the time propagation of an</span>
<span class="sd">    initial wavepacket ``test``. It takes the Faddeva function into</span>
<span class="sd">    account to compute the exact Siegert time propagation. The usual</span>
<span class="sd">    exponential terms may be taken into account, if ``with_exp`` is</span>
<span class="sd">    set to ``True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    siegerts: AnalyticBasisSet</span>
<span class="sd">        Basis set made of Siegert states only.</span>
<span class="sd">    time_grid: numpy array or list of positive numbers</span>
<span class="sd">        Times for which the propagation is evaluated. It must</span>
<span class="sd">        contain positive numbers only.</span>
<span class="sd">    with_exp: bool</span>
<span class="sd">        Sets if the usual exponential term must be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2D numpy array</span>
<span class="sd">        Matrix mat_time based on the Siegert states of the basis set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add the expontial terms only if required and define the sign</span>
    <span class="c1"># in front of the Faddeeva function</span>
    <span class="k">if</span> <span class="n">with_exp</span><span class="p">:</span>
        <span class="n">mat_time</span> <span class="o">=</span> <span class="n">_set_mat_time</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat_time</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="c1"># Make the matrix with the appropriate Feddeeva functions</span>
    <span class="n">K</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">siegerts</span><span class="o">.</span><span class="n">wavenumbers</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">)</span>
    <span class="n">mat_time</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">wofz</span><span class="p">(</span>
        <span class="o">-</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">mat_time</span>


<span class="k">def</span> <span class="nf">_set_mat_space_S</span><span class="p">(</span><span class="n">siegerts</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the mat_space matrix based on the Siegert states. This</span>
<span class="sd">    matrix can then be used to compute the time propagation of an</span>
<span class="sd">    initial wavepacket ``test``. The dictionary of weights gives the</span>
<span class="sd">    type of Siegert expansion to be used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    siegerts: AnalyticBasisSet</span>
<span class="sd">        Basis set made of Siegert states only.</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>
<span class="sd">    weights: dict</span>
<span class="sd">        Dictionary of the weights to use for the time-propagation.</span>
<span class="sd">        Keys correspond to a type of Siegert states (&#39;ab&#39; for</span>
<span class="sd">        anti-bounds, &#39;b&#39; for bounds, &#39;r&#39; for resonants and &#39;ar&#39; for</span>
<span class="sd">        anti-resonants) and the corresponding value is the weight to</span>
<span class="sd">        use for all the states of the given type (optional).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2D numpy array</span>
<span class="sd">        Matrix mat_space based on the Siegert states of the basis set.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    BasisSetError</span>
<span class="sd">        If there are not enough Siegert states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that the basis contain at least one Siegert state</span>
    <span class="k">if</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BasisSetError</span><span class="p">(</span>
            <span class="s2">&quot;The basis set must contain at least one Siegert state.&quot;</span><span class="p">)</span>
    <span class="c1"># Build the matrix mat_space_S by looping over the desired</span>
    <span class="c1"># types of Siegert states, using the desired weight.</span>
    <span class="n">mat_space_S</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">states</span> <span class="ow">in</span> <span class="p">(</span><span class="n">siegerts</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">antibounds</span><span class="p">,</span> <span class="n">siegerts</span><span class="o">.</span><span class="n">resonants</span><span class="p">,</span>
                   <span class="n">siegerts</span><span class="o">.</span><span class="n">antiresonants</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">states</span><span class="o">.</span><span class="n">is_not_empty</span><span class="p">:</span>
            <span class="n">S_type</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Siegert_type</span>
            <span class="n">contribs</span> <span class="o">=</span> <span class="n">_set_mat_space</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">weights</span><span class="p">[</span><span class="n">S_type</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">contrib</span> <span class="ow">in</span> <span class="n">contribs</span><span class="p">:</span>
                <span class="n">mat_space_S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contrib</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat_space_S</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_set_mat_space_c</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the mat_space matrix based on the continuum states.</span>
<span class="sd">    This matrix can then be used to compute the time propagation of</span>
<span class="sd">    an initial wavepacket ``test``. The integration over the</span>
<span class="sd">    continuum states is performed thanks to a vector accounting for</span>
<span class="sd">    the composite Simpson&#39;s rule (which is the integration scheme</span>
<span class="sd">    used here).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    continuum: AnalyticBasisSet</span>
<span class="sd">        Basis set made of continuum states only.</span>
<span class="sd">    test: Function</span>
<span class="sd">        Test function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2D numpy array</span>
<span class="sd">        Matrix mat_time based on the continuum states of the basis set.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    BasisSetError</span>
<span class="sd">        If there are not enough continuum states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that the basis contain at least two continuum states</span>
    <span class="c1"># (to define the wavenumber grid step)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">continuum</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BasisSetError</span><span class="p">(</span><span class="s2">&quot;Too few continuum states in the basis set.&quot;</span><span class="p">)</span>
    <span class="c1"># Prepare the integration over the continuum states with</span>
    <span class="c1"># the composite Simpson&#39;s rule (CSR):</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.</span> <span class="k">if</span> <span class="p">(</span><span class="n">ik</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="mf">2.</span>
                      <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">continuum</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hk</span> <span class="o">=</span> <span class="n">continuum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">wavenumber</span> <span class="o">-</span> <span class="n">continuum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wavenumber</span>
    <span class="n">alpha</span> <span class="o">*=</span> <span class="n">hk</span> <span class="o">/</span> <span class="mf">3.</span>
    <span class="c1"># Initialize mat_space</span>
    <span class="n">mat_space_c</span> <span class="o">=</span> <span class="n">_set_mat_space</span><span class="p">(</span><span class="n">continuum</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>
    <span class="c1"># Mutliply by the integration vector before before returning</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">mat_space_c</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_generate_time_plots</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">time_grid</span><span class="p">,</span> <span class="n">exact_tp</span><span class="p">,</span> <span class="n">exact_S_tp</span><span class="p">,</span> <span class="n">MLE_tp</span><span class="p">,</span>
                         <span class="n">Ber_tp</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">file_save</span><span class="p">):</span>  <span class="c1"># pragma: no cover  # noqa</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xgrid: numpy array</span>
<span class="sd">        Space grid used to discretize the time-propagated wavepacket.</span>
<span class="sd">    time_grid: numpy array or list of positive numbers</span>
<span class="sd">        Times for which the propagation is evaluated. It must</span>
<span class="sd">        contain positive numbers only.</span>
<span class="sd">    exact_tp: numpy array</span>
<span class="sd">        Exact time-propagation (using bound and continuum states).</span>
<span class="sd">    exact_S_tp: bool</span>
<span class="sd">        Exact Siegert states expansion of the time-propagation (using</span>
<span class="sd">        all Siegert states).</span>
<span class="sd">    MLE_tp: bool</span>
<span class="sd">        Mittag-Leffler Expansion of the time-propagation (using all</span>
<span class="sd">        Siegert states).</span>
<span class="sd">    Berggren_tp: bool</span>
<span class="sd">        Berggren expansion of the time-propagation (using bound and</span>
<span class="sd">        resonant states).</span>
<span class="sd">    xlim: tuple(float or int, float or int)</span>
<span class="sd">        Range of the x axis of the plot (optional).</span>
<span class="sd">    xlim: tuple(float or int, float or int)</span>
<span class="sd">        Range of the y axis of the plot (optional).</span>
<span class="sd">    title: str</span>
<span class="sd">        Plot title (optional).</span>
<span class="sd">    file_save: str</span>
<span class="sd">        Base name of the files where the plots are to be saved</span>
<span class="sd">        (optional).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Loop to create the plots for each time in time_grid</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_grid</span><span class="p">):</span>
        <span class="c1"># Object-oriented plots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">init_plot</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">exact_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">exact_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re[$f_</span><span class="si">{exact}</span><span class="s1">(t)$]&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">exact_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im[$f_</span><span class="si">{exact}</span><span class="s1">(t)$]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exact_S_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">exact_S_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#276419&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re[$f_{S, exact}(t)$]&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">exact_S_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#b8e186&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im[$f_{S, exact}(t)$]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">MLE_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">MLE_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#2166ac&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re[$f_</span><span class="si">{MLE}</span><span class="s1">(t)$]&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">MLE_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#d1e5f0&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im[$f_</span><span class="si">{MLE}</span><span class="s1">(t)$]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Ber_tp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Ber_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#d73027&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re[$f_</span><span class="si">{Ber}</span><span class="s1">(t)$]&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xgrid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Ber_tp</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#fc8d59&#39;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im[$f_</span><span class="si">{Ber}</span><span class="s1">(t)$]&#39;</span><span class="p">)</span>
        <span class="c1"># Set the title</span>
        <span class="n">time_str</span> <span class="o">=</span> <span class="s2">&quot;t = </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_title</span> <span class="o">=</span> <span class="n">title</span> <span class="o">+</span> <span class="s2">&quot;; &quot;</span> <span class="o">+</span> <span class="n">time_str</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_title</span> <span class="o">=</span> <span class="n">time_str</span>
        <span class="c1"># Set the output file name</span>
        <span class="k">if</span> <span class="n">file_save</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_save</span> <span class="o">+=</span> <span class="s2">&quot;_t_</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="c1"># Finalize the plot</span>
        <span class="n">finalize_plot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">new_title</span><span class="p">,</span>
                      <span class="n">file_save</span><span class="o">=</span><span class="n">file_save</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;$x$&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;$f(x, t)$&quot;</span><span class="p">,</span>
                      <span class="n">leg_loc</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">leg_bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Maxime Morinière.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>